{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tslib_1 = require(\"tslib\");\n\nconst client_1 = tslib_1.__importDefault(require(\"@walletconnect/client\"));\n\nconst qrcode_modal_1 = tslib_1.__importDefault(require(\"@walletconnect/qrcode-modal\"));\n\nconst http_connection_1 = tslib_1.__importDefault(require(\"@walletconnect/http-connection\"));\n\nconst utils_1 = require(\"@walletconnect/utils\");\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.networkId = 1;\n    this.rpcUrl = \"\";\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new client_1.default({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? qrcode_modal_1.default : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = typeof opts.chainId !== \"undefined\" ? opts.chainId : 1;\n    this.networkId = this.chainId;\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider({\n      getAccounts: cb => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const accounts = wc.accounts;\n\n          if (accounts && accounts.length) {\n            cb(null, accounts);\n          } else {\n            cb(new Error(\"Failed to get accounts\"));\n          }\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signMessage([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processPersonalMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signPersonalMessage([msgParams.data, msgParams.from]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processSignTransaction: (txParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processTransaction: (txParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.sendTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }),\n      processTypedMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const wc = yield this.getWalletConnector();\n          const result = yield wc.signTypedData([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      })\n    }));\n    this.addProvider({\n      handleRequest: (payload, next, end) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n          const {\n            result\n          } = yield this.handleRequest(payload);\n          end(null, result);\n        } catch (error) {\n          end(error);\n        }\n      }),\n      setEngine: _ => _\n    });\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  enable() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const wc = yield this.getWalletConnector();\n\n      if (wc) {\n        this.start();\n        this.subscribeWalletConnector();\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    });\n  }\n\n  request(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      return this.send(payload);\n    });\n  }\n\n  send(payload, callback) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (typeof payload === \"string\") {\n        const method = payload;\n        let params = callback;\n\n        if (method === \"personal_sign\") {\n          params = utils_1.parsePersonalSign(params);\n        }\n\n        return this.sendAsyncPromise(method, params);\n      }\n\n      payload = Object.assign({\n        id: utils_1.payloadId(),\n        jsonrpc: \"2.0\"\n      }, payload);\n\n      if (payload.method === \"personal_sign\") {\n        payload.params = utils_1.parsePersonalSign(payload.params);\n      }\n\n      if (callback) {\n        this.sendAsync(payload, callback);\n        return;\n      }\n\n      return this.sendAsyncPromise(payload.method, payload.params);\n    });\n  }\n\n  onConnect(callback) {\n    this.connectCallbacks.push(callback);\n  }\n\n  triggerConnect(result) {\n    if (this.connectCallbacks && this.connectCallbacks.length) {\n      this.connectCallbacks.forEach(callback => callback(result));\n    }\n  }\n\n  disconnect() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      this.close();\n    });\n  }\n\n  close() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const wc = yield this.getWalletConnector({\n        disableSessionCreation: true\n      });\n      yield wc.killSession();\n      yield this.onDisconnect();\n    });\n  }\n\n  handleRequest(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        let response;\n        let result = null;\n        const wc = yield this.getWalletConnector();\n\n        switch (payload.method) {\n          case \"wc_killSession\":\n            yield this.close();\n            result = null;\n            break;\n\n          case \"eth_accounts\":\n            result = wc.accounts;\n            break;\n\n          case \"eth_coinbase\":\n            result = wc.accounts[0];\n            break;\n\n          case \"eth_chainId\":\n            result = wc.chainId;\n            break;\n\n          case \"net_version\":\n            result = wc.networkId || wc.chainId;\n            break;\n\n          case \"eth_uninstallFilter\":\n            this.sendAsync(payload, _ => _);\n            result = true;\n            break;\n\n          default:\n            response = yield this.handleOtherRequests(payload);\n        }\n\n        if (response) {\n          return response;\n        }\n\n        return this.formatResponse(payload, result);\n      } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n      }\n    });\n  }\n\n  handleOtherRequests(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (!utils_1.signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n        return this.handleReadRequests(payload);\n      }\n\n      const wc = yield this.getWalletConnector();\n      const result = yield wc.sendCustomRequest(payload);\n      return this.formatResponse(payload, result);\n    });\n  }\n\n  handleReadRequests(payload) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (!this.http) {\n        const error = new Error(\"HTTP Connection not available\");\n        this.emit(\"error\", error);\n        throw error;\n      }\n\n      return this.http.send(payload);\n    });\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        const sessionRequestOpions = this.chainId ? {\n          chainId: this.chainId\n        } : undefined;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession(sessionRequestOpions).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  subscribeWalletConnector() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const wc = yield this.getWalletConnector();\n      wc.on(\"disconnect\", error => {\n        if (error) {\n          this.emit(\"error\", error);\n          return;\n        }\n\n        this.onDisconnect();\n      });\n      wc.on(\"session_update\", (error, payload) => {\n        if (error) {\n          this.emit(\"error\", error);\n          return;\n        }\n\n        this.updateState(payload.params[0]);\n      });\n    });\n  }\n\n  onDisconnect() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      yield this.stop();\n      this.emit(\"close\", 1000, \"Connection closed\");\n      this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n    });\n  }\n\n  updateState(sessionParams) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const {\n        accounts,\n        chainId,\n        networkId,\n        rpcUrl\n      } = sessionParams;\n\n      if (!this.accounts || accounts && this.accounts !== accounts) {\n        this.accounts = accounts;\n        this.emit(\"accountsChanged\", accounts);\n      }\n\n      if (!this.chainId || chainId && this.chainId !== chainId) {\n        this.chainId = chainId;\n        this.emit(\"chainChanged\", chainId);\n      }\n\n      if (!this.networkId || networkId && this.networkId !== networkId) {\n        this.networkId = networkId;\n        this.emit(\"networkChanged\", networkId);\n      }\n\n      this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n    });\n  }\n\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const infuraNetworks = {\n      1: \"mainnet\",\n      3: \"ropsten\",\n      4: \"rinkeby\",\n      5: \"goerli\",\n      42: \"kovan\"\n    };\n    const network = infuraNetworks[chainId];\n\n    if (!rpcUrl) {\n      if (this.rpc && this.rpc[chainId]) {\n        rpcUrl = this.rpc[chainId];\n      } else if (network) {\n        rpcUrl = `https://${network}.infura.io/v3/${this.infuraId}`;\n      }\n    }\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new http_connection_1.default(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: utils_1.payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n}\n\nexports.default = WalletConnectProvider;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst client_1 = tslib_1.__importDefault(require(\"@walletconnect/client\"));\nconst qrcode_modal_1 = tslib_1.__importDefault(require(\"@walletconnect/qrcode-modal\"));\nconst http_connection_1 = tslib_1.__importDefault(require(\"@walletconnect/http-connection\"));\nconst utils_1 = require(\"@walletconnect/utils\");\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\nclass WalletConnectProvider extends ProviderEngine {\n    constructor(opts) {\n        super({ pollingInterval: opts.pollingInterval || 8000 });\n        this.bridge = \"https://bridge.walletconnect.org\";\n        this.qrcode = true;\n        this.qrcodeModalOptions = undefined;\n        this.rpc = null;\n        this.infuraId = \"\";\n        this.http = null;\n        this.isConnecting = false;\n        this.connected = false;\n        this.connectCallbacks = [];\n        this.accounts = [];\n        this.chainId = 1;\n        this.networkId = 1;\n        this.rpcUrl = \"\";\n        this.bridge = opts.connector\n            ? opts.connector.bridge\n            : opts.bridge || \"https://bridge.walletconnect.org\";\n        this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n        this.qrcodeModalOptions = opts.qrcodeModalOptions;\n        this.wc =\n            opts.connector ||\n                new client_1.default({\n                    bridge: this.bridge,\n                    qrcodeModal: this.qrcode ? qrcode_modal_1.default : undefined,\n                    qrcodeModalOptions: this.qrcodeModalOptions,\n                });\n        this.rpc = opts.rpc || null;\n        if (!this.rpc &&\n            (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n            throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n        }\n        this.infuraId = opts.infuraId || \"\";\n        this.chainId = typeof opts.chainId !== \"undefined\" ? opts.chainId : 1;\n        this.networkId = this.chainId;\n        this.updateRpcUrl(this.chainId);\n        this.addProvider(new FixtureSubprovider({\n            eth_hashrate: \"0x00\",\n            eth_mining: false,\n            eth_syncing: true,\n            net_listening: true,\n            web3_clientVersion: `WalletConnect/v1.x.x/javascript`,\n        }));\n        this.addProvider(new CacheSubprovider());\n        this.addProvider(new SubscriptionsSubprovider());\n        this.addProvider(new FilterSubprovider());\n        this.addProvider(new NonceSubprovider());\n        this.addProvider(new HookedWalletSubprovider({\n            getAccounts: (cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const wc = yield this.getWalletConnector();\n                    const accounts = wc.accounts;\n                    if (accounts && accounts.length) {\n                        cb(null, accounts);\n                    }\n                    else {\n                        cb(new Error(\"Failed to get accounts\"));\n                    }\n                }\n                catch (error) {\n                    cb(error);\n                }\n            }),\n            processMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const wc = yield this.getWalletConnector();\n                    const result = yield wc.signMessage([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            }),\n            processPersonalMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const wc = yield this.getWalletConnector();\n                    const result = yield wc.signPersonalMessage([msgParams.data, msgParams.from]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            }),\n            processSignTransaction: (txParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const wc = yield this.getWalletConnector();\n                    const result = yield wc.signTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            }),\n            processTransaction: (txParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const wc = yield this.getWalletConnector();\n                    const result = yield wc.sendTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            }),\n            processTypedMessage: (msgParams, cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const wc = yield this.getWalletConnector();\n                    const result = yield wc.signTypedData([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            }),\n        }));\n        this.addProvider({\n            handleRequest: (payload, next, end) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n                try {\n                    const { result } = yield this.handleRequest(payload);\n                    end(null, result);\n                }\n                catch (error) {\n                    end(error);\n                }\n            }),\n            setEngine: (_) => _,\n        });\n    }\n    get isWalletConnect() {\n        return true;\n    }\n    get connector() {\n        return this.wc;\n    }\n    get walletMeta() {\n        return this.wc.peerMeta;\n    }\n    enable() {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const wc = yield this.getWalletConnector();\n            if (wc) {\n                this.start();\n                this.subscribeWalletConnector();\n                return wc.accounts;\n            }\n            else {\n                throw new Error(\"Failed to connect to WalleConnect\");\n            }\n        });\n    }\n    request(payload) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            return this.send(payload);\n        });\n    }\n    send(payload, callback) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (typeof payload === \"string\") {\n                const method = payload;\n                let params = callback;\n                if (method === \"personal_sign\") {\n                    params = utils_1.parsePersonalSign(params);\n                }\n                return this.sendAsyncPromise(method, params);\n            }\n            payload = Object.assign({ id: utils_1.payloadId(), jsonrpc: \"2.0\" }, payload);\n            if (payload.method === \"personal_sign\") {\n                payload.params = utils_1.parsePersonalSign(payload.params);\n            }\n            if (callback) {\n                this.sendAsync(payload, callback);\n                return;\n            }\n            return this.sendAsyncPromise(payload.method, payload.params);\n        });\n    }\n    onConnect(callback) {\n        this.connectCallbacks.push(callback);\n    }\n    triggerConnect(result) {\n        if (this.connectCallbacks && this.connectCallbacks.length) {\n            this.connectCallbacks.forEach(callback => callback(result));\n        }\n    }\n    disconnect() {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            this.close();\n        });\n    }\n    close() {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const wc = yield this.getWalletConnector({ disableSessionCreation: true });\n            yield wc.killSession();\n            yield this.onDisconnect();\n        });\n    }\n    handleRequest(payload) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            try {\n                let response;\n                let result = null;\n                const wc = yield this.getWalletConnector();\n                switch (payload.method) {\n                    case \"wc_killSession\":\n                        yield this.close();\n                        result = null;\n                        break;\n                    case \"eth_accounts\":\n                        result = wc.accounts;\n                        break;\n                    case \"eth_coinbase\":\n                        result = wc.accounts[0];\n                        break;\n                    case \"eth_chainId\":\n                        result = wc.chainId;\n                        break;\n                    case \"net_version\":\n                        result = wc.networkId || wc.chainId;\n                        break;\n                    case \"eth_uninstallFilter\":\n                        this.sendAsync(payload, (_) => _);\n                        result = true;\n                        break;\n                    default:\n                        response = yield this.handleOtherRequests(payload);\n                }\n                if (response) {\n                    return response;\n                }\n                return this.formatResponse(payload, result);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                throw error;\n            }\n        });\n    }\n    handleOtherRequests(payload) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (!utils_1.signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n                return this.handleReadRequests(payload);\n            }\n            const wc = yield this.getWalletConnector();\n            const result = yield wc.sendCustomRequest(payload);\n            return this.formatResponse(payload, result);\n        });\n    }\n    handleReadRequests(payload) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (!this.http) {\n                const error = new Error(\"HTTP Connection not available\");\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return this.http.send(payload);\n        });\n    }\n    formatResponse(payload, result) {\n        return {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result: result,\n        };\n    }\n    getWalletConnector(opts = {}) {\n        const { disableSessionCreation = false } = opts;\n        return new Promise((resolve, reject) => {\n            const wc = this.wc;\n            if (this.isConnecting) {\n                this.onConnect((x) => resolve(x));\n            }\n            else if (!wc.connected && !disableSessionCreation) {\n                this.isConnecting = true;\n                const sessionRequestOpions = this.chainId ? { chainId: this.chainId } : undefined;\n                wc.on(\"modal_closed\", () => {\n                    reject(new Error(\"User closed modal\"));\n                });\n                wc.createSession(sessionRequestOpions)\n                    .then(() => {\n                    wc.on(\"connect\", (error, payload) => {\n                        if (error) {\n                            this.isConnecting = false;\n                            return reject(error);\n                        }\n                        this.isConnecting = false;\n                        this.connected = true;\n                        if (payload) {\n                            this.updateState(payload.params[0]);\n                        }\n                        this.emit(\"connect\");\n                        this.triggerConnect(wc);\n                        resolve(wc);\n                    });\n                })\n                    .catch(error => {\n                    this.isConnecting = false;\n                    reject(error);\n                });\n            }\n            else {\n                if (!this.connected) {\n                    this.connected = true;\n                    this.updateState(wc.session);\n                }\n                resolve(wc);\n            }\n        });\n    }\n    subscribeWalletConnector() {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const wc = yield this.getWalletConnector();\n            wc.on(\"disconnect\", error => {\n                if (error) {\n                    this.emit(\"error\", error);\n                    return;\n                }\n                this.onDisconnect();\n            });\n            wc.on(\"session_update\", (error, payload) => {\n                if (error) {\n                    this.emit(\"error\", error);\n                    return;\n                }\n                this.updateState(payload.params[0]);\n            });\n        });\n    }\n    onDisconnect() {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            yield this.stop();\n            this.emit(\"close\", 1000, \"Connection closed\");\n            this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n        });\n    }\n    updateState(sessionParams) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            const { accounts, chainId, networkId, rpcUrl } = sessionParams;\n            if (!this.accounts || (accounts && this.accounts !== accounts)) {\n                this.accounts = accounts;\n                this.emit(\"accountsChanged\", accounts);\n            }\n            if (!this.chainId || (chainId && this.chainId !== chainId)) {\n                this.chainId = chainId;\n                this.emit(\"chainChanged\", chainId);\n            }\n            if (!this.networkId || (networkId && this.networkId !== networkId)) {\n                this.networkId = networkId;\n                this.emit(\"networkChanged\", networkId);\n            }\n            this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n        });\n    }\n    updateRpcUrl(chainId, rpcUrl = \"\") {\n        const infuraNetworks = {\n            1: \"mainnet\",\n            3: \"ropsten\",\n            4: \"rinkeby\",\n            5: \"goerli\",\n            42: \"kovan\",\n        };\n        const network = infuraNetworks[chainId];\n        if (!rpcUrl) {\n            if (this.rpc && this.rpc[chainId]) {\n                rpcUrl = this.rpc[chainId];\n            }\n            else if (network) {\n                rpcUrl = `https://${network}.infura.io/v3/${this.infuraId}`;\n            }\n        }\n        if (rpcUrl) {\n            this.rpcUrl = rpcUrl;\n            this.updateHttpConnection();\n        }\n        else {\n            this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n        }\n    }\n    updateHttpConnection() {\n        if (this.rpcUrl) {\n            this.http = new http_connection_1.default(this.rpcUrl);\n            this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n            this.http.on(\"error\", error => this.emit(\"error\", error));\n        }\n    }\n    sendAsyncPromise(method, params) {\n        return new Promise((resolve, reject) => {\n            this.sendAsync({\n                id: utils_1.payloadId(),\n                jsonrpc: \"2.0\",\n                method,\n                params: params || [],\n            }, (error, response) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(response.result);\n            });\n        });\n    }\n}\nexports.default = WalletConnectProvider;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}