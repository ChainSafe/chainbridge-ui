{"ast":null,"code":"const util = require('util');\n\nconst EventEmitter = require('events/');\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nmodule.exports = SafeEventEmitter;\n\nfunction SafeEventEmitter() {\n  EventEmitter.call(this);\n}\n\nutil.inherits(SafeEventEmitter, EventEmitter);\n\nSafeEventEmitter.prototype.emit = function (type) {\n  // copied from https://github.com/Gozala/events/blob/master/events.js\n  // modified lines are commented with \"edited:\"\n  var args = [];\n\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    } // At least give some kind of context to the user\n\n\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    // edited: using safeApply\n    safeApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) // edited: using safeApply\n    safeApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction safeApply(handler, context, args) {\n  try {\n    ReflectApply(handler, context, args);\n  } catch (err) {\n    // throw error after timeout so as not to interupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n\n  return copy;\n}","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/safe-event-emitter/index.js"],"names":["util","require","EventEmitter","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","module","exports","SafeEventEmitter","inherits","emit","type","i","arguments","length","push","doError","events","_events","undefined","error","er","Error","err","message","context","handler","safeApply","len","listeners","arrayClone","setTimeout","arr","n","copy","Array"],"mappings":"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","sourcesContent":["const util = require('util')\nconst EventEmitter = require('events/')\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n}\n\nmodule.exports = SafeEventEmitter\n\n\nfunction SafeEventEmitter() {\n  EventEmitter.call(this)\n}\n\nutil.inherits(SafeEventEmitter, EventEmitter)\n\nSafeEventEmitter.prototype.emit = function (type) {\n  // copied from https://github.com/Gozala/events/blob/master/events.js\n  // modified lines are commented with \"edited:\"\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    // edited: using safeApply\n    safeApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      // edited: using safeApply\n      safeApply(listeners[i], this, args);\n  }\n\n  return true;\n}\n\nfunction safeApply(handler, context, args) {\n  try {\n    ReflectApply(handler, context, args)\n  } catch (err) {\n    // throw error after timeout so as not to interupt the stack\n    setTimeout(() => {\n      throw err\n    })\n  }\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n"]},"metadata":{},"sourceType":"script"}