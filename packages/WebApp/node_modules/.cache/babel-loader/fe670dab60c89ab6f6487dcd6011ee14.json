{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst signature_1 = require(\"elliptic/lib/elliptic/ec/signature\");\n\nconst random_1 = require(\"../../random\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst helpers_1 = require(\"../../helpers\");\n\nconst ec = new elliptic_1.ec('secp256k1');\n\nfunction ellipticCompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  const pubPoint = ec.keyFromPublic(publicKey);\n  const hex = pubPoint.getPublic().encode(constants_1.HEX_ENC, true);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticCompress = ellipticCompress;\n\nfunction ellipticDecompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  const pubPoint = ec.keyFromPublic(publicKey);\n  const hex = pubPoint.getPublic().encode(constants_1.HEX_ENC, false);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticDecompress = ellipticDecompress;\n\nfunction ellipticGeneratePrivate() {\n  let privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n\n  while (!ellipticVerifyPrivateKey(privateKey)) {\n    privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n  }\n\n  return privateKey;\n}\n\nexports.ellipticGeneratePrivate = ellipticGeneratePrivate;\n\nfunction ellipticVerifyPrivateKey(privateKey) {\n  return helpers_1.isValidPrivateKey(privateKey);\n}\n\nexports.ellipticVerifyPrivateKey = ellipticVerifyPrivateKey;\n\nfunction ellipticGetPublic(privateKey) {\n  const hex = ec.keyFromPrivate(privateKey).getPublic(false, constants_1.HEX_ENC);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticGetPublic = ellipticGetPublic;\n\nfunction ellipticGetPublicCompressed(privateKey) {\n  const hex = ec.keyFromPrivate(privateKey).getPublic(true, constants_1.HEX_ENC);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticGetPublicCompressed = ellipticGetPublicCompressed;\n\nfunction ellipticDerive(publicKeyB, privateKeyA) {\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic());\n  return Buffer.from(Px.toArray());\n}\n\nexports.ellipticDerive = ellipticDerive;\n\nfunction ellipticSignatureExport(sig) {\n  return signature_1.Signature({\n    r: sig.slice(0, 32),\n    s: sig.slice(32, 64),\n    recoveryParam: helpers_1.importRecoveryParam(sig.slice(64, 65))\n  }).toDER();\n}\n\nexports.ellipticSignatureExport = ellipticSignatureExport;\n\nfunction ellipticSign(msg, privateKey, rsvSig = false) {\n  const signature = ec.sign(msg, privateKey, {\n    canonical: true\n  });\n  return rsvSig ? helpers_1.concatBuffers(helpers_1.hexToBuffer(helpers_1.sanitizeHex(signature.r.toString(16))), helpers_1.hexToBuffer(helpers_1.sanitizeHex(signature.s.toString(16))), helpers_1.exportRecoveryParam(signature.recoveryParam || 0)) : Buffer.from(signature.toDER());\n}\n\nexports.ellipticSign = ellipticSign;\n\nfunction ellipticRecover(sig, msg, compressed = false) {\n  if (helpers_1.isValidDERSignature(sig)) {\n    throw new Error('Cannot recover from DER signatures');\n  }\n\n  const signature = helpers_1.splitSignature(sig);\n  const recoveryParam = helpers_1.importRecoveryParam(signature.v);\n  const hex = ec.recoverPubKey(msg, {\n    r: helpers_1.removeHexLeadingZeros(helpers_1.bufferToHex(signature.r)),\n    s: helpers_1.removeHexLeadingZeros(helpers_1.bufferToHex(signature.s)),\n    recoveryParam\n  }, recoveryParam).encode(constants_1.HEX_ENC, compressed);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticRecover = ellipticRecover;\n\nfunction ellipticVerify(sig, msg, publicKey) {\n  if (!helpers_1.isValidDERSignature) {\n    sig = ellipticSignatureExport(sig);\n  }\n\n  return ec.verify(msg, sig, publicKey);\n}\n\nexports.ellipticVerify = ellipticVerify;","map":{"version":3,"sources":["../../../../src/lib/elliptic/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst elliptic_1 = require(\"elliptic\");\nconst signature_1 = require(\"elliptic/lib/elliptic/ec/signature\");\nconst random_1 = require(\"../../random\");\nconst constants_1 = require(\"../../constants\");\nconst helpers_1 = require(\"../../helpers\");\nconst ec = new elliptic_1.ec('secp256k1');\nfunction ellipticCompress(publicKey) {\n    publicKey = helpers_1.sanitizePublicKey(publicKey);\n    const pubPoint = ec.keyFromPublic(publicKey);\n    const hex = pubPoint.getPublic().encode(constants_1.HEX_ENC, true);\n    return helpers_1.hexToBuffer(hex);\n}\nexports.ellipticCompress = ellipticCompress;\nfunction ellipticDecompress(publicKey) {\n    publicKey = helpers_1.sanitizePublicKey(publicKey);\n    const pubPoint = ec.keyFromPublic(publicKey);\n    const hex = pubPoint.getPublic().encode(constants_1.HEX_ENC, false);\n    return helpers_1.hexToBuffer(hex);\n}\nexports.ellipticDecompress = ellipticDecompress;\nfunction ellipticGeneratePrivate() {\n    let privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n    while (!ellipticVerifyPrivateKey(privateKey)) {\n        privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n    }\n    return privateKey;\n}\nexports.ellipticGeneratePrivate = ellipticGeneratePrivate;\nfunction ellipticVerifyPrivateKey(privateKey) {\n    return helpers_1.isValidPrivateKey(privateKey);\n}\nexports.ellipticVerifyPrivateKey = ellipticVerifyPrivateKey;\nfunction ellipticGetPublic(privateKey) {\n    const hex = ec.keyFromPrivate(privateKey).getPublic(false, constants_1.HEX_ENC);\n    return helpers_1.hexToBuffer(hex);\n}\nexports.ellipticGetPublic = ellipticGetPublic;\nfunction ellipticGetPublicCompressed(privateKey) {\n    const hex = ec.keyFromPrivate(privateKey).getPublic(true, constants_1.HEX_ENC);\n    return helpers_1.hexToBuffer(hex);\n}\nexports.ellipticGetPublicCompressed = ellipticGetPublicCompressed;\nfunction ellipticDerive(publicKeyB, privateKeyA) {\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic());\n    return Buffer.from(Px.toArray());\n}\nexports.ellipticDerive = ellipticDerive;\nfunction ellipticSignatureExport(sig) {\n    return signature_1.Signature({\n        r: sig.slice(0, 32),\n        s: sig.slice(32, 64),\n        recoveryParam: helpers_1.importRecoveryParam(sig.slice(64, 65)),\n    }).toDER();\n}\nexports.ellipticSignatureExport = ellipticSignatureExport;\nfunction ellipticSign(msg, privateKey, rsvSig = false) {\n    const signature = ec.sign(msg, privateKey, { canonical: true });\n    return rsvSig\n        ? helpers_1.concatBuffers(helpers_1.hexToBuffer(helpers_1.sanitizeHex(signature.r.toString(16))), helpers_1.hexToBuffer(helpers_1.sanitizeHex(signature.s.toString(16))), helpers_1.exportRecoveryParam(signature.recoveryParam || 0))\n        : Buffer.from(signature.toDER());\n}\nexports.ellipticSign = ellipticSign;\nfunction ellipticRecover(sig, msg, compressed = false) {\n    if (helpers_1.isValidDERSignature(sig)) {\n        throw new Error('Cannot recover from DER signatures');\n    }\n    const signature = helpers_1.splitSignature(sig);\n    const recoveryParam = helpers_1.importRecoveryParam(signature.v);\n    const hex = ec\n        .recoverPubKey(msg, {\n        r: helpers_1.removeHexLeadingZeros(helpers_1.bufferToHex(signature.r)),\n        s: helpers_1.removeHexLeadingZeros(helpers_1.bufferToHex(signature.s)),\n        recoveryParam,\n    }, recoveryParam)\n        .encode(constants_1.HEX_ENC, compressed);\n    return helpers_1.hexToBuffer(hex);\n}\nexports.ellipticRecover = ellipticRecover;\nfunction ellipticVerify(sig, msg, publicKey) {\n    if (!helpers_1.isValidDERSignature) {\n        sig = ellipticSignatureExport(sig);\n    }\n    return ec.verify(msg, sig, publicKey);\n}\nexports.ellipticVerify = ellipticVerify;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}