{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { eventToSentryRequest } from '@sentry/core';\nimport { SyncPromise } from '@sentry/utils';\nimport { BaseTransport } from './base';\n/** `XHR` based transport */\n\nvar XHRTransport =\n/** @class */\nfunction (_super) {\n  __extends(XHRTransport, _super);\n\n  function XHRTransport() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  XHRTransport.prototype.sendEvent = function (event) {\n    var _this = this;\n\n    var eventType = event.type || 'event';\n\n    if (this._isRateLimited(eventType)) {\n      return Promise.reject({\n        event: event,\n        reason: \"Transport locked till \" + this._disabledUntil(eventType) + \" due to too many requests.\",\n        status: 429\n      });\n    }\n\n    var sentryReq = eventToSentryRequest(event, this._api);\n    return this._buffer.add(new SyncPromise(function (resolve, reject) {\n      var request = new XMLHttpRequest();\n\n      request.onreadystatechange = function () {\n        if (request.readyState === 4) {\n          var headers = {\n            'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n            'retry-after': request.getResponseHeader('Retry-After')\n          };\n\n          _this._handleResponse({\n            eventType: eventType,\n            response: request,\n            headers: headers,\n            resolve: resolve,\n            reject: reject\n          });\n        }\n      };\n\n      request.open('POST', sentryReq.url);\n\n      for (var header in _this.options.headers) {\n        if (_this.options.headers.hasOwnProperty(header)) {\n          request.setRequestHeader(header, _this.options.headers[header]);\n        }\n      }\n\n      request.send(sentryReq.body);\n    }));\n  };\n\n  return XHRTransport;\n}(BaseTransport);\n\nexport { XHRTransport };","map":{"version":3,"sources":["../../src/transports/xhr.ts"],"names":[],"mappings":";AAAA,SAAS,oBAAT,QAAqC,cAArC;AAEA,SAAS,WAAT,QAA4B,eAA5B;AAEA,SAAS,aAAT,QAA8B,QAA9B;AAEA;;AACA,IAAA,YAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAkC,EAAA,SAAA,CAAA,YAAA,EAAA,MAAA,CAAA;;AAAlC,WAAA,YAAA,GAAA;;AAyCC;AAxCC;;;;;AAGO,EAAA,YAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,KAAjB,EAA6B;AAA7B,QAAA,KAAA,GAAA,IAAA;;AACE,QAAM,SAAS,GAAG,KAAK,CAAC,IAAN,IAAc,OAAhC;;AAEA,QAAI,KAAK,cAAL,CAAoB,SAApB,CAAJ,EAAoC;AAClC,aAAO,OAAO,CAAC,MAAR,CAAe;AACpB,QAAA,KAAK,EAAA,KADe;AAEpB,QAAA,MAAM,EAAE,2BAAyB,KAAK,cAAL,CAAoB,SAApB,CAAzB,GAAuD,4BAF3C;AAGpB,QAAA,MAAM,EAAE;AAHY,OAAf,CAAP;AAKD;;AAED,QAAM,SAAS,GAAG,oBAAoB,CAAC,KAAD,EAAQ,KAAK,IAAb,CAAtC;AAEA,WAAO,KAAK,OAAL,CAAa,GAAb,CACL,IAAI,WAAJ,CAA0B,UAAC,OAAD,EAAU,MAAV,EAAgB;AACxC,UAAM,OAAO,GAAG,IAAI,cAAJ,EAAhB;;AAEA,MAAA,OAAO,CAAC,kBAAR,GAA6B,YAAA;AAC3B,YAAI,OAAO,CAAC,UAAR,KAAuB,CAA3B,EAA8B;AAC5B,cAAM,OAAO,GAAG;AACd,oCAAwB,OAAO,CAAC,iBAAR,CAA0B,sBAA1B,CADV;AAEd,2BAAe,OAAO,CAAC,iBAAR,CAA0B,aAA1B;AAFD,WAAhB;;AAIA,UAAA,KAAI,CAAC,eAAL,CAAqB;AAAE,YAAA,SAAS,EAAA,SAAX;AAAa,YAAA,QAAQ,EAAE,OAAvB;AAAgC,YAAA,OAAO,EAAA,OAAvC;AAAyC,YAAA,OAAO,EAAA,OAAhD;AAAkD,YAAA,MAAM,EAAA;AAAxD,WAArB;AACD;AACF,OARD;;AAUA,MAAA,OAAO,CAAC,IAAR,CAAa,MAAb,EAAqB,SAAS,CAAC,GAA/B;;AACA,WAAK,IAAM,MAAX,IAAqB,KAAI,CAAC,OAAL,CAAa,OAAlC,EAA2C;AACzC,YAAI,KAAI,CAAC,OAAL,CAAa,OAAb,CAAqB,cAArB,CAAoC,MAApC,CAAJ,EAAiD;AAC/C,UAAA,OAAO,CAAC,gBAAR,CAAyB,MAAzB,EAAiC,KAAI,CAAC,OAAL,CAAa,OAAb,CAAqB,MAArB,CAAjC;AACD;AACF;;AACD,MAAA,OAAO,CAAC,IAAR,CAAa,SAAS,CAAC,IAAvB;AACD,KApBD,CADK,CAAP;AAuBD,GApCM;;AAqCT,SAAA,YAAA;AAAC,CAzCD,CAAkC,aAAlC,CAAA","sourcesContent":["import { eventToSentryRequest } from '@sentry/core';\nimport { Event, Response } from '@sentry/types';\nimport { SyncPromise } from '@sentry/utils';\n\nimport { BaseTransport } from './base';\n\n/** `XHR` based transport */\nexport class XHRTransport extends BaseTransport {\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<Response> {\n    const eventType = event.type || 'event';\n\n    if (this._isRateLimited(eventType)) {\n      return Promise.reject({\n        event,\n        reason: `Transport locked till ${this._disabledUntil(eventType)} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    const sentryReq = eventToSentryRequest(event, this._api);\n\n    return this._buffer.add(\n      new SyncPromise<Response>((resolve, reject) => {\n        const request = new XMLHttpRequest();\n\n        request.onreadystatechange = (): void => {\n          if (request.readyState === 4) {\n            const headers = {\n              'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': request.getResponseHeader('Retry-After'),\n            };\n            this._handleResponse({ eventType, response: request, headers, resolve, reject });\n          }\n        };\n\n        request.open('POST', sentryReq.url);\n        for (const header in this.options.headers) {\n          if (this.options.headers.hasOwnProperty(header)) {\n            request.setRequestHeader(header, this.options.headers[header]);\n          }\n        }\n        request.send(sentryReq.body);\n      }),\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}