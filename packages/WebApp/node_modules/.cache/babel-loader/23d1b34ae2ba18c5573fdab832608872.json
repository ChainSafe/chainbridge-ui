{"ast":null,"code":"/* eslint-disable no-useless-escape */\nconst utils = require('ethereumjs-util');\n\nconst BN = require('bn.js');\n\nvar ABI = function () {}; // Convert from short to canonical names\n// FIXME: optimise or make this nicer?\n\n\nfunction elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n\n  return name;\n}\n\nABI.eventID = function (name, types) {\n  // FIXME: use node.js util.format?\n  var sig = name + '(' + types.map(elementaryName).join(',') + ')';\n  return utils.keccak256(Buffer.from(sig));\n};\n\nABI.methodID = function (name, types) {\n  return ABI.eventID(name, types).slice(0, 4);\n}; // Parse N from type<N>\n\n\nfunction parseTypeN(type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n} // Parse N,M from type<N>x<M>\n\n\nfunction parseTypeNxM(type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n} // Parse N in type[<N>] where \"type\" can itself be an array type.\n\n\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n\n  return null;\n}\n\nfunction parseNumber(arg) {\n  var type = typeof arg;\n\n  if (type === 'string') {\n    if (utils.isHexPrefixed(arg)) {\n      return new BN(utils.stripHexPrefix(arg), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n} // someMethod(bytes,uint)\n// someMethod(bytes,uint):(boolean)\n\n\nfunction parseSignature(sig) {\n  var tmp = /^(\\w+)\\((.*)\\)$/.exec(sig);\n\n  if (tmp.length !== 3) {\n    throw new Error('Invalid method signature');\n  }\n\n  var args = /^(.+)\\):\\((.+)$/.exec(tmp[2]);\n\n  if (args !== null && args.length === 3) {\n    return {\n      method: tmp[1],\n      args: args[1].split(','),\n      retargs: args[2].split(',')\n    };\n  } else {\n    var params = tmp[2].split(',');\n\n    if (params.length === 1 && params[0] === '') {\n      // Special-case (possibly naive) fixup for functions that take no arguments.\n      // TODO: special cases are always bad, but this makes the function return\n      // match what the calling functions expect\n      params = [];\n    }\n\n    return {\n      method: tmp[1],\n      args: params\n    };\n  }\n} // Encodes a single item (can be dynamic array)\n// @returns: Buffer\n\n\nfunction encodeSingle(type, arg) {\n  var size, num, ret, i;\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg));\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0);\n  } else if (type === 'string') {\n    return encodeSingle('bytes', Buffer.from(arg, 'utf8'));\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?');\n    }\n\n    size = parseTypeArray(type);\n\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size);\n    }\n\n    ret = [];\n    type = type.slice(0, type.lastIndexOf('['));\n\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg);\n    }\n\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]));\n    }\n\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length);\n      ret.unshift(length);\n    }\n\n    return Buffer.concat(ret);\n  } else if (type === 'bytes') {\n    arg = Buffer.from(arg);\n    ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n\n    if (arg.length % 32 !== 0) {\n      ret = Buffer.concat([ret, utils.zeros(32 - arg.length % 32)]);\n    }\n\n    return ret;\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n\n    return utils.setLengthRight(arg, 32);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n\n    num = parseNumber(arg);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative');\n    }\n\n    return num.toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n\n    num = parseNumber(arg);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type);\n    num = parseNumber(arg);\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative');\n    }\n\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type);\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type);\n} // Decodes a single item (can be dynamic array)\n// @returns: array\n// FIXME: this method will need a lot of attention at checking limits and validation\n\n\nfunction decodeSingle(parsedType, data, offset) {\n  if (typeof parsedType === 'string') {\n    parsedType = parseType(parsedType);\n  }\n\n  var size, num, ret, i;\n\n  if (parsedType.name === 'address') {\n    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex');\n  } else if (parsedType.name === 'bool') {\n    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();\n  } else if (parsedType.name === 'string') {\n    var bytes = decodeSingle(parsedType.rawType, data, offset);\n    return Buffer.from(bytes, 'utf8').toString();\n  } else if (parsedType.isArray) {\n    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    ret = [];\n    size = parsedType.size;\n\n    if (parsedType.size === 'dynamic') {\n      offset = decodeSingle('uint256', data, offset).toNumber();\n      size = decodeSingle('uint256', data, offset).toNumber();\n      offset = offset + 32;\n    }\n\n    for (i = 0; i < size; i++) {\n      var decoded = decodeSingle(parsedType.subArray, data, offset);\n      ret.push(decoded);\n      offset += parsedType.subArray.memoryUsage;\n    }\n\n    return ret;\n  } else if (parsedType.name === 'bytes') {\n    offset = decodeSingle('uint256', data, offset).toNumber();\n    size = decodeSingle('uint256', data, offset).toNumber();\n    return data.slice(offset + 32, offset + 32 + size);\n  } else if (parsedType.name.startsWith('bytes')) {\n    return data.slice(offset, offset + parsedType.size);\n  } else if (parsedType.name.startsWith('uint')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be');\n\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n    }\n\n    return num;\n  } else if (parsedType.name.startsWith('int')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256);\n\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength());\n    }\n\n    return num;\n  } else if (parsedType.name.startsWith('ufixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]));\n    num = decodeSingle('uint256', data, offset);\n\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet');\n    }\n\n    return num.div(size);\n  } else if (parsedType.name.startsWith('fixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]));\n    num = decodeSingle('int256', data, offset);\n\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet');\n    }\n\n    return num.div(size);\n  }\n\n  throw new Error('Unsupported or invalid type: ' + parsedType.name);\n} // Parse the given type\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\n\n\nfunction parseType(type) {\n  var size;\n  var ret;\n\n  if (isArray(type)) {\n    size = parseTypeArray(type);\n    var subArray = type.slice(0, type.lastIndexOf('['));\n    subArray = parseType(subArray);\n    ret = {\n      isArray: true,\n      name: type,\n      size: size,\n      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\n      subArray: subArray\n    };\n    return ret;\n  } else {\n    var rawType;\n\n    switch (type) {\n      case 'address':\n        rawType = 'uint160';\n        break;\n\n      case 'bool':\n        rawType = 'uint8';\n        break;\n\n      case 'string':\n        rawType = 'bytes';\n        break;\n    }\n\n    ret = {\n      rawType: rawType,\n      name: type,\n      memoryUsage: 32\n    };\n\n    if (type.startsWith('bytes') && type !== 'bytes' || type.startsWith('uint') || type.startsWith('int')) {\n      ret.size = parseTypeN(type);\n    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\n      ret.size = parseTypeNxM(type);\n    }\n\n    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\n      throw new Error('Invalid bytes<N> width: ' + ret.size);\n    }\n\n    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n      throw new Error('Invalid int/uint<N> width: ' + ret.size);\n    }\n\n    return ret;\n  }\n} // Is a type dynamic?\n\n\nfunction isDynamic(type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';\n} // Is a type an array?\n\n\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n} // Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\n\n\nABI.rawEncode = function (types, values) {\n  var output = [];\n  var data = [];\n  var headLength = 0;\n  types.forEach(function (type) {\n    if (isArray(type)) {\n      var size = parseTypeArray(type);\n\n      if (size !== 'dynamic') {\n        headLength += 32 * size;\n      } else {\n        headLength += 32;\n      }\n    } else {\n      headLength += 32;\n    }\n  });\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    var cur = encodeSingle(type, value); // Use the head/tail method for storing dynamic data\n\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength));\n      data.push(cur);\n      headLength += cur.length;\n    } else {\n      output.push(cur);\n    }\n  }\n\n  return Buffer.concat(output.concat(data));\n};\n\nABI.rawDecode = function (types, data) {\n  var ret = [];\n  data = Buffer.from(data);\n  var offset = 0;\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var parsed = parseType(type, data, offset);\n    var decoded = decodeSingle(parsed, data, offset);\n    offset += parsed.memoryUsage;\n    ret.push(decoded);\n  }\n\n  return ret;\n};\n\nABI.simpleEncode = function (method) {\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  var sig = parseSignature(method); // FIXME: validate/convert arguments\n\n  if (args.length !== sig.args.length) {\n    throw new Error('Argument count mismatch');\n  }\n\n  return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);\n};\n\nABI.simpleDecode = function (method, data) {\n  var sig = parseSignature(method); // FIXME: validate/convert arguments\n\n  if (!sig.retargs) {\n    throw new Error('No return values in method');\n  }\n\n  return ABI.rawDecode(sig.retargs, data);\n};\n\nfunction stringify(type, value) {\n  if (type.startsWith('address') || type.startsWith('bytes')) {\n    return '0x' + value.toString('hex');\n  } else {\n    return value.toString();\n  }\n}\n\nABI.stringify = function (types, values) {\n  var ret = [];\n\n  for (var i in types) {\n    var type = types[i];\n    var value = values[i]; // if it is an array type, concat the items\n\n    if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n      value = value.map(function (item) {\n        return stringify(type, item);\n      }).join(', ');\n    } else {\n      value = stringify(type, value);\n    }\n\n    ret.push(value);\n  }\n\n  return ret;\n};\n\nABI.solidityHexValue = function (type, value, bitsize) {\n  // pass in bitsize = null if use default bitsize\n  var size, num;\n\n  if (isArray(type)) {\n    var subType = type.replace(/\\[.*?\\]/, '');\n\n    if (!isArray(subType)) {\n      var arraySize = parseTypeArray(type);\n\n      if (arraySize !== 'dynamic' && arraySize !== 0 && value.length > arraySize) {\n        throw new Error('Elements exceed array size: ' + arraySize);\n      }\n    }\n\n    var arrayValues = value.map(function (v) {\n      return ABI.solidityHexValue(subType, v, 256);\n    });\n    return Buffer.concat(arrayValues);\n  } else if (type === 'bytes') {\n    return value;\n  } else if (type === 'string') {\n    return Buffer.from(value, 'utf8');\n  } else if (type === 'bool') {\n    bitsize = bitsize || 8;\n    var padding = Array(bitsize / 4).join('0');\n    return Buffer.from(value ? padding + '1' : padding + '0', 'hex');\n  } else if (type === 'address') {\n    var bytesize = 20;\n\n    if (bitsize) {\n      bytesize = bitsize / 8;\n    }\n\n    return utils.setLengthLeft(value, bytesize);\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n\n    return utils.setLengthRight(value, size);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n\n    num = parseNumber(value);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    bitsize = bitsize || size;\n    return num.toArrayLike(Buffer, 'be', bitsize / 8);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n\n    num = parseNumber(value);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    bitsize = bitsize || size;\n    return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8);\n  } else {\n    // FIXME: support all other types\n    throw new Error('Unsupported or invalid type: ' + type);\n  }\n};\n\nABI.solidityPack = function (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values');\n  }\n\n  var ret = [];\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    ret.push(ABI.solidityHexValue(type, value, null));\n  }\n\n  return Buffer.concat(ret);\n};\n\nABI.soliditySHA3 = function (types, values) {\n  return utils.keccak256(ABI.solidityPack(types, values));\n};\n\nABI.soliditySHA256 = function (types, values) {\n  return utils.sha256(ABI.solidityPack(types, values));\n};\n\nABI.solidityRIPEMD160 = function (types, values) {\n  return utils.ripemd160(ABI.solidityPack(types, values), true);\n}; // Serpent's users are familiar with this encoding\n// - s: string\n// - b: bytes\n// - b<N>: bytes<N>\n// - i: int256\n// - a: int256[]\n\n\nfunction isNumeric(c) {\n  // FIXME: is this correct? Seems to work\n  return c >= '0' && c <= '9';\n} // For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\n\n\nABI.fromSerpent = function (sig) {\n  var ret = [];\n\n  for (var i = 0; i < sig.length; i++) {\n    var type = sig[i];\n\n    if (type === 's') {\n      ret.push('bytes');\n    } else if (type === 'b') {\n      var tmp = 'bytes';\n      var j = i + 1;\n\n      while (j < sig.length && isNumeric(sig[j])) {\n        tmp += sig[j] - '0';\n        j++;\n      }\n\n      i = j - 1;\n      ret.push(tmp);\n    } else if (type === 'i') {\n      ret.push('int256');\n    } else if (type === 'a') {\n      ret.push('int256[]');\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n\n  return ret;\n};\n\nABI.toSerpent = function (types) {\n  var ret = [];\n\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i];\n\n    if (type === 'bytes') {\n      ret.push('s');\n    } else if (type.startsWith('bytes')) {\n      ret.push('b' + parseTypeN(type));\n    } else if (type === 'int256') {\n      ret.push('i');\n    } else if (type === 'int256[]') {\n      ret.push('a');\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n\n  return ret.join('');\n};\n\nmodule.exports = ABI;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/ethereumjs-abi/lib/index.js"],"names":["utils","require","BN","ABI","elementaryName","name","startsWith","slice","eventID","types","sig","map","join","keccak256","Buffer","from","methodID","parseTypeN","type","parseInt","exec","parseTypeNxM","tmp","parseTypeArray","match","parseNumber","arg","isHexPrefixed","stripHexPrefix","toArray","Error","parseSignature","length","args","method","split","retargs","params","encodeSingle","size","num","ret","i","isArray","lastIndexOf","JSON","parse","push","unshift","concat","zeros","setLengthRight","bitLength","toArrayLike","toTwos","mul","pow","decodeSingle","parsedType","data","offset","parseType","rawType","toString","bytes","toNumber","decoded","subArray","memoryUsage","fromTwos","mod","isZero","div","isDynamic","rawEncode","values","output","headLength","forEach","value","cur","rawDecode","parsed","simpleEncode","Array","prototype","call","arguments","simpleDecode","stringify","test","item","solidityHexValue","bitsize","subType","replace","arraySize","arrayValues","v","padding","bytesize","setLengthLeft","solidityPack","soliditySHA3","soliditySHA256","sha256","solidityRIPEMD160","ripemd160","isNumeric","c","fromSerpent","j","toSerpent","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-useless-escape */\nconst utils = require('ethereumjs-util')\nconst BN = require('bn.js')\n\nvar ABI = function () {\n}\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName (name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3)\n  } else if (name === 'int') {\n    return 'int256'\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4)\n  } else if (name === 'uint') {\n    return 'uint256'\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5)\n  } else if (name === 'fixed') {\n    return 'fixed128x128'\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6)\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128'\n  }\n  return name\n}\n\nABI.eventID = function (name, types) {\n  // FIXME: use node.js util.format?\n  var sig = name + '(' + types.map(elementaryName).join(',') + ')'\n  return utils.keccak256(Buffer.from(sig))\n}\n\nABI.methodID = function (name, types) {\n  return ABI.eventID(name, types).slice(0, 4)\n}\n\n// Parse N from type<N>\nfunction parseTypeN (type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM (type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\n  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray (type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)\n  }\n  return null\n}\n\nfunction parseNumber (arg) {\n  var type = typeof arg\n  if (type === 'string') {\n    if (utils.isHexPrefixed(arg)) {\n      return new BN(utils.stripHexPrefix(arg), 16)\n    } else {\n      return new BN(arg, 10)\n    }\n  } else if (type === 'number') {\n    return new BN(arg)\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg\n  } else {\n    throw new Error('Argument is not a number')\n  }\n}\n\n// someMethod(bytes,uint)\n// someMethod(bytes,uint):(boolean)\nfunction parseSignature (sig) {\n  var tmp = /^(\\w+)\\((.*)\\)$/.exec(sig)\n\n  if (tmp.length !== 3) {\n    throw new Error('Invalid method signature')\n  }\n\n  var args = /^(.+)\\):\\((.+)$/.exec(tmp[2])\n\n  if (args !== null && args.length === 3) {\n    return {\n      method: tmp[1],\n      args: args[1].split(','),\n      retargs: args[2].split(',')\n    }\n  } else {\n    var params = tmp[2].split(',')\n    if (params.length === 1 && params[0] === '') {\n      // Special-case (possibly naive) fixup for functions that take no arguments.\n      // TODO: special cases are always bad, but this makes the function return\n      // match what the calling functions expect\n      params = []\n    }\n    return {\n      method: tmp[1],\n      args: params\n    }\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle (type, arg) {\n  var size, num, ret, i\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg))\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0)\n  } else if (type === 'string') {\n    return encodeSingle('bytes', Buffer.from(arg, 'utf8'))\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?')\n    }\n    size = parseTypeArray(type)\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size)\n    }\n    ret = []\n    type = type.slice(0, type.lastIndexOf('['))\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg)\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]))\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length)\n      ret.unshift(length)\n    }\n    return Buffer.concat(ret)\n  } else if (type === 'bytes') {\n    arg = Buffer.from(arg)\n\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\n\n    if ((arg.length % 32) !== 0) {\n      ret = Buffer.concat([ ret, utils.zeros(32 - (arg.length % 32)) ])\n    }\n\n    return ret\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return utils.setLengthRight(arg, 32)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative')\n    }\n\n    return num.toArrayLike(Buffer, 'be', 32)\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type)\n\n    num = parseNumber(arg)\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative')\n    }\n\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type)\n\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type)\n}\n\n// Decodes a single item (can be dynamic array)\n// @returns: array\n// FIXME: this method will need a lot of attention at checking limits and validation\nfunction decodeSingle (parsedType, data, offset) {\n  if (typeof parsedType === 'string') {\n    parsedType = parseType(parsedType)\n  }\n  var size, num, ret, i\n\n  if (parsedType.name === 'address') {\n    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, 'be', 20).toString('hex')\n  } else if (parsedType.name === 'bool') {\n    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString()\n  } else if (parsedType.name === 'string') {\n    var bytes = decodeSingle(parsedType.rawType, data, offset)\n    return Buffer.from(bytes, 'utf8').toString()\n  } else if (parsedType.isArray) {\n    // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    ret = []\n    size = parsedType.size\n\n    if (parsedType.size === 'dynamic') {\n      offset = decodeSingle('uint256', data, offset).toNumber()\n      size = decodeSingle('uint256', data, offset).toNumber()\n      offset = offset + 32\n    }\n    for (i = 0; i < size; i++) {\n      var decoded = decodeSingle(parsedType.subArray, data, offset)\n      ret.push(decoded)\n      offset += parsedType.subArray.memoryUsage\n    }\n    return ret\n  } else if (parsedType.name === 'bytes') {\n    offset = decodeSingle('uint256', data, offset).toNumber()\n    size = decodeSingle('uint256', data, offset).toNumber()\n    return data.slice(offset + 32, offset + 32 + size)\n  } else if (parsedType.name.startsWith('bytes')) {\n    return data.slice(offset, offset + parsedType.size)\n  } else if (parsedType.name.startsWith('uint')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be')\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded int exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())\n    }\n    return num\n  } else if (parsedType.name.startsWith('int')) {\n    num = new BN(data.slice(offset, offset + 32), 16, 'be').fromTwos(256)\n    if (num.bitLength() > parsedType.size) {\n      throw new Error('Decoded uint exceeds width: ' + parsedType.size + ' vs ' + num.bitLength())\n    }\n\n    return num\n  } else if (parsedType.name.startsWith('ufixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]))\n    num = decodeSingle('uint256', data, offset)\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet')\n    }\n    return num.div(size)\n  } else if (parsedType.name.startsWith('fixed')) {\n    size = new BN(2).pow(new BN(parsedType.size[1]))\n    num = decodeSingle('int256', data, offset)\n    if (!num.mod(size).isZero()) {\n      throw new Error('Decimals not supported yet')\n    }\n    return num.div(size)\n  }\n  throw new Error('Unsupported or invalid type: ' + parsedType.name)\n}\n\n// Parse the given type\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\nfunction parseType (type) {\n  var size\n  var ret\n  if (isArray(type)) {\n    size = parseTypeArray(type)\n    var subArray = type.slice(0, type.lastIndexOf('['))\n    subArray = parseType(subArray)\n    ret = {\n      isArray: true,\n      name: type,\n      size: size,\n      memoryUsage: size === 'dynamic' ? 32 : subArray.memoryUsage * size,\n      subArray: subArray\n    }\n    return ret\n  } else {\n    var rawType\n    switch (type) {\n      case 'address':\n        rawType = 'uint160'\n        break\n      case 'bool':\n        rawType = 'uint8'\n        break\n      case 'string':\n        rawType = 'bytes'\n        break\n    }\n    ret = {\n      rawType: rawType,\n      name: type,\n      memoryUsage: 32\n    }\n\n    if ((type.startsWith('bytes') && type !== 'bytes') || type.startsWith('uint') || type.startsWith('int')) {\n      ret.size = parseTypeN(type)\n    } else if (type.startsWith('ufixed') || type.startsWith('fixed')) {\n      ret.size = parseTypeNxM(type)\n    }\n\n    if (type.startsWith('bytes') && type !== 'bytes' && (ret.size < 1 || ret.size > 32)) {\n      throw new Error('Invalid bytes<N> width: ' + ret.size)\n    }\n    if ((type.startsWith('uint') || type.startsWith('int')) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n      throw new Error('Invalid int/uint<N> width: ' + ret.size)\n    }\n    return ret\n  }\n}\n\n// Is a type dynamic?\nfunction isDynamic (type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\n}\n\n// Is a type an array?\nfunction isArray (type) {\n  return type.lastIndexOf(']') === type.length - 1\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nABI.rawEncode = function (types, values) {\n  var output = []\n  var data = []\n\n  var headLength = 0\n\n  types.forEach(function (type) {\n    if (isArray(type)) {\n      var size = parseTypeArray(type)\n\n      if (size !== 'dynamic') {\n        headLength += 32 * size\n      } else {\n        headLength += 32\n      }\n    } else {\n      headLength += 32\n    }\n  })\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    var cur = encodeSingle(type, value)\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength))\n      data.push(cur)\n      headLength += cur.length\n    } else {\n      output.push(cur)\n    }\n  }\n\n  return Buffer.concat(output.concat(data))\n}\n\nABI.rawDecode = function (types, data) {\n  var ret = []\n  data = Buffer.from(data)\n  var offset = 0\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var parsed = parseType(type, data, offset)\n    var decoded = decodeSingle(parsed, data, offset)\n    offset += parsed.memoryUsage\n    ret.push(decoded)\n  }\n  return ret\n}\n\nABI.simpleEncode = function (method) {\n  var args = Array.prototype.slice.call(arguments).slice(1)\n  var sig = parseSignature(method)\n\n  // FIXME: validate/convert arguments\n  if (args.length !== sig.args.length) {\n    throw new Error('Argument count mismatch')\n  }\n\n  return Buffer.concat([ ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args) ])\n}\n\nABI.simpleDecode = function (method, data) {\n  var sig = parseSignature(method)\n\n  // FIXME: validate/convert arguments\n  if (!sig.retargs) {\n    throw new Error('No return values in method')\n  }\n\n  return ABI.rawDecode(sig.retargs, data)\n}\n\nfunction stringify (type, value) {\n  if (type.startsWith('address') || type.startsWith('bytes')) {\n    return '0x' + value.toString('hex')\n  } else {\n    return value.toString()\n  }\n}\n\nABI.stringify = function (types, values) {\n  var ret = []\n\n  for (var i in types) {\n    var type = types[i]\n    var value = values[i]\n\n    // if it is an array type, concat the items\n    if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n      value = value.map(function (item) {\n        return stringify(type, item)\n      }).join(', ')\n    } else {\n      value = stringify(type, value)\n    }\n\n    ret.push(value)\n  }\n\n  return ret\n}\n\nABI.solidityHexValue = function (type, value, bitsize) {\n  // pass in bitsize = null if use default bitsize\n  var size, num\n  if (isArray(type)) {\n    var subType = type.replace(/\\[.*?\\]/, '')\n    if (!isArray(subType)) {\n      var arraySize = parseTypeArray(type)\n      if (arraySize !== 'dynamic' && arraySize !== 0 && value.length > arraySize) {\n        throw new Error('Elements exceed array size: ' + arraySize)\n      }\n    }\n    var arrayValues = value.map(function (v) {\n      return ABI.solidityHexValue(subType, v, 256)\n    })\n    return Buffer.concat(arrayValues)\n  } else if (type === 'bytes') {\n    return value\n  } else if (type === 'string') {\n    return Buffer.from(value, 'utf8')\n  } else if (type === 'bool') {\n    bitsize = bitsize || 8\n    var padding = Array((bitsize) / 4).join('0')\n    return Buffer.from(value ? padding + '1' : padding + '0', 'hex')\n  } else if (type === 'address') {\n    var bytesize = 20\n    if (bitsize) {\n      bytesize = bitsize / 8\n    }\n    return utils.setLengthLeft(value, bytesize)\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return utils.setLengthRight(value, size)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(value)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    bitsize = bitsize || size\n    return num.toArrayLike(Buffer, 'be', bitsize / 8)\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(value)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    bitsize = bitsize || size\n    return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8)\n  } else {\n    // FIXME: support all other types\n    throw new Error('Unsupported or invalid type: ' + type)\n  }\n}\n\nABI.solidityPack = function (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values')\n  }\n\n  var ret = []\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    ret.push(ABI.solidityHexValue(type, value, null))\n  }\n\n  return Buffer.concat(ret)\n}\n\nABI.soliditySHA3 = function (types, values) {\n  return utils.keccak256(ABI.solidityPack(types, values))\n}\n\nABI.soliditySHA256 = function (types, values) {\n  return utils.sha256(ABI.solidityPack(types, values))\n}\n\nABI.solidityRIPEMD160 = function (types, values) {\n  return utils.ripemd160(ABI.solidityPack(types, values), true)\n}\n\n// Serpent's users are familiar with this encoding\n// - s: string\n// - b: bytes\n// - b<N>: bytes<N>\n// - i: int256\n// - a: int256[]\n\nfunction isNumeric (c) {\n  // FIXME: is this correct? Seems to work\n  return (c >= '0') && (c <= '9')\n}\n\n// For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\nABI.fromSerpent = function (sig) {\n  var ret = []\n  for (var i = 0; i < sig.length; i++) {\n    var type = sig[i]\n    if (type === 's') {\n      ret.push('bytes')\n    } else if (type === 'b') {\n      var tmp = 'bytes'\n      var j = i + 1\n      while ((j < sig.length) && isNumeric(sig[j])) {\n        tmp += sig[j] - '0'\n        j++\n      }\n      i = j - 1\n      ret.push(tmp)\n    } else if (type === 'i') {\n      ret.push('int256')\n    } else if (type === 'a') {\n      ret.push('int256[]')\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n  return ret\n}\n\nABI.toSerpent = function (types) {\n  var ret = []\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i]\n    if (type === 'bytes') {\n      ret.push('s')\n    } else if (type.startsWith('bytes')) {\n      ret.push('b' + parseTypeN(type))\n    } else if (type === 'int256') {\n      ret.push('i')\n    } else if (type === 'int256[]') {\n      ret.push('a')\n    } else {\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n  return ret.join('')\n}\n\nmodule.exports = ABI\n"]},"metadata":{},"sourceType":"script"}