{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _secp256k1 = __importStar(require(\"secp256k1\"));\n\nconst random_1 = require(\"../../random\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst helpers_1 = require(\"../../helpers\");\n\nexports.secp256k1 = _secp256k1;\n\nfunction secp256k1Compress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  return exports.secp256k1.publicKeyConvert(publicKey, true);\n}\n\nexports.secp256k1Compress = secp256k1Compress;\n\nfunction secp256k1Decompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  return exports.secp256k1.publicKeyConvert(publicKey, false);\n}\n\nexports.secp256k1Decompress = secp256k1Decompress;\n\nfunction secp256k1GeneratePrivate() {\n  let privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n\n  while (!secp256k1VerifyPrivateKey(privateKey)) {\n    privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n  }\n\n  return privateKey;\n}\n\nexports.secp256k1GeneratePrivate = secp256k1GeneratePrivate;\n\nfunction secp256k1VerifyPrivateKey(privateKey) {\n  return exports.secp256k1.privateKeyVerify(privateKey);\n}\n\nexports.secp256k1VerifyPrivateKey = secp256k1VerifyPrivateKey;\n\nfunction secp256k1GetPublic(privateKey) {\n  const result = exports.secp256k1.publicKeyCreate(privateKey, false);\n  return result;\n}\n\nexports.secp256k1GetPublic = secp256k1GetPublic;\n\nfunction secp256k1GetPublicCompressed(privateKey) {\n  const result = exports.secp256k1.publicKeyCreate(privateKey, true);\n  return result;\n}\n\nexports.secp256k1GetPublicCompressed = secp256k1GetPublicCompressed;\n\nfunction secp256k1SignatureExport(sig) {\n  return exports.secp256k1.signatureExport(sig);\n}\n\nexports.secp256k1SignatureExport = secp256k1SignatureExport;\n\nfunction secp256k1SignatureImport(sig) {\n  return exports.secp256k1.signatureImport(sig);\n}\n\nexports.secp256k1SignatureImport = secp256k1SignatureImport;\n\nfunction secp256k1Sign(msg, privateKey, rsvSig = false) {\n  const {\n    signature,\n    recovery\n  } = exports.secp256k1.sign(msg, privateKey);\n  return rsvSig ? helpers_1.concatBuffers(signature, helpers_1.exportRecoveryParam(recovery)) : secp256k1SignatureExport(signature);\n}\n\nexports.secp256k1Sign = secp256k1Sign;\n\nfunction secp256k1Recover(sig, msg, compressed = false) {\n  if (helpers_1.isValidDERSignature(sig)) {\n    throw new Error('Cannot recover from DER signatures');\n  }\n\n  const {\n    signature,\n    recovery\n  } = helpers_1.sanitizeRSVSignature(sig);\n  return exports.secp256k1.recover(msg, signature, recovery, compressed);\n}\n\nexports.secp256k1Recover = secp256k1Recover;\n\nfunction secp256k1Verify(sig, msg, publicKey) {\n  if (helpers_1.isValidDERSignature(sig)) {\n    sig = secp256k1SignatureImport(sig);\n  }\n\n  sig = helpers_1.sanitizeRSVSignature(sig).signature;\n  return exports.secp256k1.verify(msg, sig, publicKey);\n}\n\nexports.secp256k1Verify = secp256k1Verify;\n\nfunction secp256k1Derive(publicKey, privateKey, compressed) {\n  let result = exports.secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);\n  return helpers_1.trimLeft(result, constants_1.KEY_LENGTH);\n}\n\nexports.secp256k1Derive = secp256k1Derive;","map":{"version":3,"sources":["../../../../src/lib/secp256k1/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _secp256k1 = __importStar(require(\"secp256k1\"));\nconst random_1 = require(\"../../random\");\nconst constants_1 = require(\"../../constants\");\nconst helpers_1 = require(\"../../helpers\");\nexports.secp256k1 = _secp256k1;\nfunction secp256k1Compress(publicKey) {\n    publicKey = helpers_1.sanitizePublicKey(publicKey);\n    return exports.secp256k1.publicKeyConvert(publicKey, true);\n}\nexports.secp256k1Compress = secp256k1Compress;\nfunction secp256k1Decompress(publicKey) {\n    publicKey = helpers_1.sanitizePublicKey(publicKey);\n    return exports.secp256k1.publicKeyConvert(publicKey, false);\n}\nexports.secp256k1Decompress = secp256k1Decompress;\nfunction secp256k1GeneratePrivate() {\n    let privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n    while (!secp256k1VerifyPrivateKey(privateKey)) {\n        privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n    }\n    return privateKey;\n}\nexports.secp256k1GeneratePrivate = secp256k1GeneratePrivate;\nfunction secp256k1VerifyPrivateKey(privateKey) {\n    return exports.secp256k1.privateKeyVerify(privateKey);\n}\nexports.secp256k1VerifyPrivateKey = secp256k1VerifyPrivateKey;\nfunction secp256k1GetPublic(privateKey) {\n    const result = exports.secp256k1.publicKeyCreate(privateKey, false);\n    return result;\n}\nexports.secp256k1GetPublic = secp256k1GetPublic;\nfunction secp256k1GetPublicCompressed(privateKey) {\n    const result = exports.secp256k1.publicKeyCreate(privateKey, true);\n    return result;\n}\nexports.secp256k1GetPublicCompressed = secp256k1GetPublicCompressed;\nfunction secp256k1SignatureExport(sig) {\n    return exports.secp256k1.signatureExport(sig);\n}\nexports.secp256k1SignatureExport = secp256k1SignatureExport;\nfunction secp256k1SignatureImport(sig) {\n    return exports.secp256k1.signatureImport(sig);\n}\nexports.secp256k1SignatureImport = secp256k1SignatureImport;\nfunction secp256k1Sign(msg, privateKey, rsvSig = false) {\n    const { signature, recovery } = exports.secp256k1.sign(msg, privateKey);\n    return rsvSig\n        ? helpers_1.concatBuffers(signature, helpers_1.exportRecoveryParam(recovery))\n        : secp256k1SignatureExport(signature);\n}\nexports.secp256k1Sign = secp256k1Sign;\nfunction secp256k1Recover(sig, msg, compressed = false) {\n    if (helpers_1.isValidDERSignature(sig)) {\n        throw new Error('Cannot recover from DER signatures');\n    }\n    const { signature, recovery } = helpers_1.sanitizeRSVSignature(sig);\n    return exports.secp256k1.recover(msg, signature, recovery, compressed);\n}\nexports.secp256k1Recover = secp256k1Recover;\nfunction secp256k1Verify(sig, msg, publicKey) {\n    if (helpers_1.isValidDERSignature(sig)) {\n        sig = secp256k1SignatureImport(sig);\n    }\n    sig = helpers_1.sanitizeRSVSignature(sig).signature;\n    return exports.secp256k1.verify(msg, sig, publicKey);\n}\nexports.secp256k1Verify = secp256k1Verify;\nfunction secp256k1Derive(publicKey, privateKey, compressed) {\n    let result = exports.secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);\n    return helpers_1.trimLeft(result, constants_1.KEY_LENGTH);\n}\nexports.secp256k1Derive = secp256k1Derive;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}