{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar defaults = require(\"lodash.defaults\");\n\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nvar SturdyWebSocket =\n/** @class */\nfunction () {\n  function SturdyWebSocket(url, protocolsOrOptions, options) {\n    this.url = url;\n    this.onclose = null;\n    this.onerror = null;\n    this.onmessage = null;\n    this.onopen = null;\n    this.ondown = null;\n    this.onreopen = null;\n    this.CONNECTING = SturdyWebSocket.CONNECTING;\n    this.OPEN = SturdyWebSocket.OPEN;\n    this.CLOSING = SturdyWebSocket.CLOSING;\n    this.CLOSED = SturdyWebSocket.CLOSED;\n    this.hasBeenOpened = false;\n    this.isClosed = false;\n    this.messageBuffer = [];\n    this.nextRetryTime = 0;\n    this.reconnectCount = 0;\n    this.lastKnownExtensions = \"\";\n    this.lastKnownProtocol = \"\";\n    this.listeners = {};\n\n    if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) {\n      this.protocols = protocolsOrOptions;\n    } else {\n      options = protocolsOrOptions;\n    }\n\n    this.options = defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);\n\n    if (!this.options.wsConstructor) {\n      if (typeof WebSocket !== \"undefined\") {\n        this.options.wsConstructor = WebSocket;\n      } else {\n        throw new Error(\"WebSocket not present in global scope and no \" + \"wsConstructor option was provided.\");\n      }\n    }\n\n    this.openNewWebSocket();\n  }\n\n  Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n    get: function () {\n      return this.binaryTypeInternal || \"blob\";\n    },\n    set: function (binaryType) {\n      this.binaryTypeInternal = binaryType;\n\n      if (this.ws) {\n        this.ws.binaryType = binaryType;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n    get: function () {\n      var sum = this.ws ? this.ws.bufferedAmount : 0;\n      var hasUnknownAmount = false;\n      this.messageBuffer.forEach(function (data) {\n        var byteLength = getDataByteLength(data);\n\n        if (byteLength != null) {\n          sum += byteLength;\n        } else {\n          hasUnknownAmount = true;\n        }\n      });\n\n      if (hasUnknownAmount) {\n        this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" + \" return value may be below the correct amount.\");\n      }\n\n      return sum;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n    get: function () {\n      return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n    get: function () {\n      return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n    get: function () {\n      return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SturdyWebSocket.prototype.close = function (code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n\n    this.shutdown();\n    this.debugLog(\"WebSocket permanently closed by client.\");\n  };\n\n  SturdyWebSocket.prototype.send = function (data) {\n    if (this.ws && this.ws.readyState === this.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.messageBuffer.push(data);\n    }\n  };\n\n  SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  };\n\n  SturdyWebSocket.prototype.dispatchEvent = function (event) {\n    return this.dispatchEventOfType(event.type, event);\n  };\n\n  SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n    if (this.listeners[type]) {\n      this.listeners[type] = this.listeners[type].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  };\n\n  SturdyWebSocket.prototype.openNewWebSocket = function () {\n    var _this = this;\n\n    if (this.isClosed) {\n      return;\n    }\n\n    var _a = this.options,\n        connectTimeout = _a.connectTimeout,\n        wsConstructor = _a.wsConstructor;\n    this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n    var ws = new wsConstructor(this.url, this.protocols);\n\n    ws.onclose = function (event) {\n      return _this.handleClose(event);\n    };\n\n    ws.onerror = function (event) {\n      return _this.handleError(event);\n    };\n\n    ws.onmessage = function (event) {\n      return _this.handleMessage(event);\n    };\n\n    ws.onopen = function (event) {\n      return _this.handleOpen(event);\n    };\n\n    this.connectTimeoutId = setTimeout(function () {\n      // If this is running, we still haven't opened the websocket.\n      // Kill it so we can try again.\n      _this.clearConnectTimeout();\n\n      ws.close();\n    }, connectTimeout);\n    this.ws = ws;\n  };\n\n  SturdyWebSocket.prototype.handleOpen = function (event) {\n    var _this = this;\n\n    if (!this.ws || this.isClosed) {\n      return;\n    }\n\n    var allClearResetTime = this.options.allClearResetTime;\n    this.debugLog(\"WebSocket opened.\");\n\n    if (this.binaryTypeInternal != null) {\n      this.ws.binaryType = this.binaryTypeInternal;\n    } else {\n      this.binaryTypeInternal = this.ws.binaryType;\n    }\n\n    this.clearConnectTimeout();\n\n    if (this.hasBeenOpened) {\n      this.dispatchEventOfType(\"reopen\", event);\n    } else {\n      this.dispatchEventOfType(\"open\", event);\n      this.hasBeenOpened = true;\n    }\n\n    this.messageBuffer.forEach(function (message) {\n      return _this.send(message);\n    });\n    this.messageBuffer = [];\n    this.allClearTimeoutId = setTimeout(function () {\n      _this.clearAllClearTimeout();\n\n      _this.nextRetryTime = 0;\n      _this.reconnectCount = 0;\n      var openTime = allClearResetTime / 1000 | 0;\n\n      _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n    }, allClearResetTime);\n  };\n\n  SturdyWebSocket.prototype.handleMessage = function (event) {\n    if (this.isClosed) {\n      return;\n    }\n\n    this.dispatchEventOfType(\"message\", event);\n  };\n\n  SturdyWebSocket.prototype.handleClose = function (event) {\n    var _this = this;\n\n    if (this.isClosed) {\n      return;\n    }\n\n    var _a = this.options,\n        maxReconnectAttempts = _a.maxReconnectAttempts,\n        shouldReconnect = _a.shouldReconnect;\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n\n    if (this.ws) {\n      this.lastKnownExtensions = this.ws.extensions;\n      this.lastKnownProtocol = this.ws.protocol;\n      this.ws = undefined;\n    }\n\n    this.dispatchEventOfType(\"down\", event);\n\n    if (this.reconnectCount >= maxReconnectAttempts) {\n      this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n      return;\n    }\n\n    var willReconnect = shouldReconnect(event);\n\n    if (typeof willReconnect === \"boolean\") {\n      this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n    } else {\n      willReconnect.then(function (willReconnectResolved) {\n        if (_this.isClosed) {\n          return;\n        }\n\n        _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n      });\n    }\n  };\n\n  SturdyWebSocket.prototype.handleError = function (event) {\n    this.dispatchEventOfType(\"error\", event);\n    this.debugLog(\"WebSocket encountered an error.\");\n  };\n\n  SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n    if (willReconnect) {\n      this.reconnect();\n    } else {\n      this.stopReconnecting(event, denialReason);\n    }\n  };\n\n  SturdyWebSocket.prototype.reconnect = function () {\n    var _this = this;\n\n    var _a = this.options,\n        minReconnectDelay = _a.minReconnectDelay,\n        maxReconnectDelay = _a.maxReconnectDelay,\n        reconnectBackoffFactor = _a.reconnectBackoffFactor;\n    this.reconnectCount++;\n    var retryTime = this.nextRetryTime;\n    this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n    setTimeout(function () {\n      return _this.openNewWebSocket();\n    }, retryTime);\n    var retryTimeSeconds = retryTime / 1000 | 0;\n    this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n  };\n\n  SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n    this.debugLog(debugReason);\n    this.shutdown();\n    this.dispatchEventOfType(\"close\", event);\n  };\n\n  SturdyWebSocket.prototype.shutdown = function () {\n    this.isClosed = true;\n    this.clearAllTimeouts();\n    this.messageBuffer = [];\n  };\n\n  SturdyWebSocket.prototype.clearAllTimeouts = function () {\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n  };\n\n  SturdyWebSocket.prototype.clearConnectTimeout = function () {\n    if (this.connectTimeoutId != null) {\n      clearTimeout(this.connectTimeoutId);\n      this.connectTimeoutId = undefined;\n    }\n  };\n\n  SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n    if (this.allClearTimeoutId != null) {\n      clearTimeout(this.allClearTimeoutId);\n      this.allClearTimeoutId = undefined;\n    }\n  };\n\n  SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n    var _this = this;\n\n    switch (type) {\n      case \"close\":\n        if (this.onclose) {\n          this.onclose(event);\n        }\n\n        break;\n\n      case \"error\":\n        if (this.onerror) {\n          this.onerror(event);\n        }\n\n        break;\n\n      case \"message\":\n        if (this.onmessage) {\n          this.onmessage(event);\n        }\n\n        break;\n\n      case \"open\":\n        if (this.onopen) {\n          this.onopen(event);\n        }\n\n        break;\n\n      case \"down\":\n        if (this.ondown) {\n          this.ondown(event);\n        }\n\n        break;\n\n      case \"reopen\":\n        if (this.onreopen) {\n          this.onreopen(event);\n        }\n\n        break;\n    }\n\n    if (type in this.listeners) {\n      this.listeners[type].slice().forEach(function (listener) {\n        return _this.callListener(listener, event);\n      });\n    }\n\n    return !event || !event.defaultPrevented;\n  };\n\n  SturdyWebSocket.prototype.callListener = function (listener, event) {\n    if (typeof listener === \"function\") {\n      listener.call(this, event);\n    } else {\n      listener.handleEvent.call(this, event);\n    }\n  };\n\n  SturdyWebSocket.prototype.debugLog = function (message) {\n    if (this.options.debug) {\n      // tslint:disable-next-line:no-console\n      console.log(message);\n    }\n  };\n\n  SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n    var maxReconnectAttempts = this.options.maxReconnectAttempts;\n    return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n  };\n\n  SturdyWebSocket.DEFAULT_OPTIONS = {\n    allClearResetTime: 5000,\n    connectTimeout: 5000,\n    debug: false,\n    minReconnectDelay: 1000,\n    maxReconnectDelay: 30000,\n    maxReconnectAttempts: Number.POSITIVE_INFINITY,\n    reconnectBackoffFactor: 1.5,\n    shouldReconnect: function () {\n      return true;\n    },\n    wsConstructor: undefined\n  };\n  SturdyWebSocket.CONNECTING = 0;\n  SturdyWebSocket.OPEN = 1;\n  SturdyWebSocket.CLOSING = 2;\n  SturdyWebSocket.CLOSED = 3;\n  return SturdyWebSocket;\n}();\n\nexports.default = SturdyWebSocket;\n\nfunction getDataByteLength(data) {\n  if (typeof data === \"string\") {\n    // UTF-16 strings use two bytes per character.\n    return 2 * data.length;\n  } else if (data instanceof ArrayBuffer) {\n    return data.byteLength;\n  } else if (data instanceof Blob) {\n    return data.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction pluralize(s, n) {\n  return n === 1 ? s : s + \"s\";\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import defaults = require(\"lodash.defaults\");\n\nexport interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (\n        url: string,\n        protocols?: string | string[],\n    ) => WebSocket;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options?: Options,\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            ws.close();\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.ws = undefined;\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reconnect();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reconnect(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(event: CloseEvent, debugReason: string): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        this.dispatchEventOfType(\"close\", event);\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}