{"ast":null,"code":"const cacheUtils = require('./cache-utils.js');\n\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware'); // `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\n\n\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\nmodule.exports = createBlockCacheMiddleware;\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const {\n    blockTracker\n  } = opts;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified'); // create caching strategies\n\n  const blockCache = new BlockCacheStrategy();\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next();\n    } // check type and matching strategy\n\n\n    const type = cacheUtils.cacheTypeForPayload(req);\n    const strategy = strategies[type]; // If there's no strategy in place, pass it down the chain.\n\n    if (!strategy) {\n      return next();\n    } // If the strategy can't cache this request, ignore it.\n\n\n    if (!strategy.canCacheRequest(req)) {\n      return next();\n    } // get block reference (number or keyword)\n\n\n    let blockTag = cacheUtils.blockTagForPayload(req);\n    if (!blockTag) blockTag = 'latest'; // get exact block number\n\n    let requestedBlockNumber;\n\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00';\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock(); // clear all cache before latest block\n\n      blockCache.clearBefore(latestBlockNumber);\n      requestedBlockNumber = latestBlockNumber;\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag;\n    } // end on a hit, continue on a miss\n\n\n    const cacheResult = await strategy.get(req, requestedBlockNumber);\n\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next(); // add result to cache\n\n      await strategy.set(req, requestedBlockNumber, res.result);\n    } else {\n      // fill in result from cache\n      res.result = cacheResult;\n    }\n  });\n} //\n// Cache Strategies\n//\n\n\nclass BlockCacheStrategy {\n  constructor() {\n    this.cache = {};\n  }\n\n  getBlockCacheForPayload(payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16);\n    let blockCache = this.cache[blockNumber]; // create new cache if necesary\n\n    if (!blockCache) {\n      const newCache = {};\n      this.cache[blockNumber] = newCache;\n      blockCache = newCache;\n    }\n\n    return blockCache;\n  }\n\n  async get(payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    if (!blockCache) return; // lookup payload in block cache\n\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n    const cached = blockCache[identifier]; // may be undefined\n\n    return cached;\n  }\n\n  async set(payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result);\n    if (!canCache) return; // set the value in the cache\n\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n    blockCache[identifier] = result;\n  }\n\n  canCacheRequest(payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false;\n    } // check blockTag\n\n\n    const blockTag = cacheUtils.blockTagForPayload(payload);\n\n    if (blockTag === 'pending') {\n      return false;\n    } // can be cached\n\n\n    return true;\n  }\n\n  canCacheResult(payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return; // check if transactions have block reference before caching\n\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false;\n      }\n    } // otherwise true\n\n\n    return true;\n  } // removes all block caches with block number lower than `oldBlockHex`\n\n\n  clearBefore(oldBlockHex) {\n    const self = this;\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16); // clear old caches\n\n    Object.keys(self.cache).map(Number).filter(num => num < oldBlockNumber).forEach(num => delete self.cache[num]);\n  }\n\n}","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/eth-json-rpc-middleware/block-cache.js"],"names":["cacheUtils","require","createAsyncMiddleware","emptyValues","undefined","module","exports","createBlockCacheMiddleware","opts","blockTracker","Error","blockCache","BlockCacheStrategy","strategies","perma","block","fork","req","res","next","skipCache","type","cacheTypeForPayload","strategy","canCacheRequest","blockTag","blockTagForPayload","requestedBlockNumber","latestBlockNumber","getLatestBlock","clearBefore","cacheResult","get","set","result","constructor","cache","getBlockCacheForPayload","payload","blockNumberHex","blockNumber","Number","parseInt","newCache","identifier","cacheIdentifierForPayload","cached","canCache","canCacheResult","includes","method","blockHash","oldBlockHex","self","oldBlockNumber","Object","keys","map","filter","num","forEach"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,2CAAD,CAArC,C,CACA;;;AACA,MAAME,WAAW,GAAG,CAACC,SAAD,EAAY,IAAZ,EAAkB,iBAAlB,CAApB;AAEAC,MAAM,CAACC,OAAP,GAAiBC,0BAAjB;;AAGA,SAASA,0BAAT,CAAoCC,IAAI,GAAG,EAA3C,EAA+C;AAC7C;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAmBD,IAAzB;AACA,MAAI,CAACC,YAAL,EAAmB,MAAM,IAAIC,KAAJ,CAAU,wDAAV,CAAN,CAH0B,CAK7C;;AACA,QAAMC,UAAU,GAAG,IAAIC,kBAAJ,EAAnB;AACA,QAAMC,UAAU,GAAG;AACjBC,IAAAA,KAAK,EAAEH,UADU;AAEjBI,IAAAA,KAAK,EAAEJ,UAFU;AAGjBK,IAAAA,IAAI,EAAEL;AAHW,GAAnB;AAMA,SAAOT,qBAAqB,CAAC,OAAOe,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB,KAA0B;AACrD;AACA,QAAIF,GAAG,CAACG,SAAR,EAAmB;AACjB,aAAOD,IAAI,EAAX;AACD,KAJoD,CAKrD;;;AACA,UAAME,IAAI,GAAGrB,UAAU,CAACsB,mBAAX,CAA+BL,GAA/B,CAAb;AACA,UAAMM,QAAQ,GAAGV,UAAU,CAACQ,IAAD,CAA3B,CAPqD,CAQrD;;AACA,QAAI,CAACE,QAAL,EAAe;AACb,aAAOJ,IAAI,EAAX;AACD,KAXoD,CAYrD;;;AACA,QAAI,CAACI,QAAQ,CAACC,eAAT,CAAyBP,GAAzB,CAAL,EAAoC;AAClC,aAAOE,IAAI,EAAX;AACD,KAfoD,CAiBrD;;;AACA,QAAIM,QAAQ,GAAGzB,UAAU,CAAC0B,kBAAX,CAA8BT,GAA9B,CAAf;AACA,QAAI,CAACQ,QAAL,EAAeA,QAAQ,GAAG,QAAX,CAnBsC,CAqBrD;;AACA,QAAIE,oBAAJ;;AACA,QAAIF,QAAQ,KAAK,UAAjB,EAA6B;AAC3B;AACAE,MAAAA,oBAAoB,GAAG,MAAvB;AACD,KAHD,MAGO,IAAIF,QAAQ,KAAK,QAAjB,EAA2B;AAChC;AACA,YAAMG,iBAAiB,GAAG,MAAMnB,YAAY,CAACoB,cAAb,EAAhC,CAFgC,CAGhC;;AACAlB,MAAAA,UAAU,CAACmB,WAAX,CAAuBF,iBAAvB;AACAD,MAAAA,oBAAoB,GAAGC,iBAAvB;AACD,KANM,MAMA;AACL;AACAD,MAAAA,oBAAoB,GAAGF,QAAvB;AACD,KAnCoD,CAqCrD;;;AACA,UAAMM,WAAW,GAAG,MAAMR,QAAQ,CAACS,GAAT,CAAaf,GAAb,EAAkBU,oBAAlB,CAA1B;;AACA,QAAII,WAAW,KAAK3B,SAApB,EAA+B;AAC7B;AACA;AACA,YAAMe,IAAI,EAAV,CAH6B,CAI7B;;AACA,YAAMI,QAAQ,CAACU,GAAT,CAAahB,GAAb,EAAkBU,oBAAlB,EAAwCT,GAAG,CAACgB,MAA5C,CAAN;AACD,KAND,MAMO;AACL;AACAhB,MAAAA,GAAG,CAACgB,MAAJ,GAAaH,WAAb;AACD;AACF,GAjD2B,CAA5B;AAkDD,C,CAGD;AACA;AACA;;;AAEA,MAAMnB,kBAAN,CAAyB;AAEvBuB,EAAAA,WAAW,GAAI;AACb,SAAKC,KAAL,GAAa,EAAb;AACD;;AAEDC,EAAAA,uBAAuB,CAAEC,OAAF,EAAWC,cAAX,EAA2B;AAChD,UAAMC,WAAW,GAAGC,MAAM,CAACC,QAAP,CAAgBH,cAAhB,EAAgC,EAAhC,CAApB;AACA,QAAI5B,UAAU,GAAG,KAAKyB,KAAL,CAAWI,WAAX,CAAjB,CAFgD,CAGhD;;AACA,QAAI,CAAC7B,UAAL,EAAiB;AACf,YAAMgC,QAAQ,GAAG,EAAjB;AACA,WAAKP,KAAL,CAAWI,WAAX,IAA0BG,QAA1B;AACAhC,MAAAA,UAAU,GAAGgC,QAAb;AACD;;AACD,WAAOhC,UAAP;AACD;;AAED,QAAMqB,GAAN,CAAWM,OAAX,EAAoBX,oBAApB,EAA0C;AACxC;AACA,UAAMhB,UAAU,GAAG,KAAK0B,uBAAL,CAA6BC,OAA7B,EAAsCX,oBAAtC,CAAnB;AACA,QAAI,CAAChB,UAAL,EAAiB,OAHuB,CAIxC;;AACA,UAAMiC,UAAU,GAAG5C,UAAU,CAAC6C,yBAAX,CAAqCP,OAArC,EAA8C,IAA9C,CAAnB;AACA,UAAMQ,MAAM,GAAGnC,UAAU,CAACiC,UAAD,CAAzB,CANwC,CAOxC;;AACA,WAAOE,MAAP;AACD;;AAED,QAAMb,GAAN,CAAWK,OAAX,EAAoBX,oBAApB,EAA0CO,MAA1C,EAAkD;AAChD;AACA,UAAMa,QAAQ,GAAG,KAAKC,cAAL,CAAoBV,OAApB,EAA6BJ,MAA7B,CAAjB;AACA,QAAI,CAACa,QAAL,EAAe,OAHiC,CAIhD;;AACA,UAAMpC,UAAU,GAAG,KAAK0B,uBAAL,CAA6BC,OAA7B,EAAsCX,oBAAtC,CAAnB;AACA,UAAMiB,UAAU,GAAG5C,UAAU,CAAC6C,yBAAX,CAAqCP,OAArC,EAA8C,IAA9C,CAAnB;AACA3B,IAAAA,UAAU,CAACiC,UAAD,CAAV,GAAyBV,MAAzB;AACD;;AAEDV,EAAAA,eAAe,CAAEc,OAAF,EAAW;AACxB;AACA,QAAI,CAACtC,UAAU,CAAC+C,QAAX,CAAoBT,OAApB,CAAL,EAAmC;AACjC,aAAO,KAAP;AACD,KAJuB,CAKxB;;;AACA,UAAMb,QAAQ,GAAGzB,UAAU,CAAC0B,kBAAX,CAA8BY,OAA9B,CAAjB;;AACA,QAAIb,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,aAAO,KAAP;AACD,KATuB,CAUxB;;;AACA,WAAO,IAAP;AACD;;AAEDuB,EAAAA,cAAc,CAAEV,OAAF,EAAWJ,MAAX,EAAmB;AAC/B;AACA,QAAI/B,WAAW,CAAC8C,QAAZ,CAAqBf,MAArB,CAAJ,EAAkC,OAFH,CAG/B;;AACA,QAAI,CAAC,0BAAD,EAA6B,2BAA7B,EAA0De,QAA1D,CAAmEX,OAAO,CAACY,MAA3E,CAAJ,EAAwF;AACtF,UAAI,CAAChB,MAAD,IAAW,CAACA,MAAM,CAACiB,SAAnB,IAAgCjB,MAAM,CAACiB,SAAP,KAAqB,oEAAzD,EAA+H;AAC7H,eAAO,KAAP;AACD;AACF,KAR8B,CAS/B;;;AACA,WAAO,IAAP;AACD,GAhEsB,CAkEvB;;;AACArB,EAAAA,WAAW,CAAEsB,WAAF,EAAc;AACvB,UAAMC,IAAI,GAAG,IAAb;AACA,UAAMC,cAAc,GAAGb,MAAM,CAACC,QAAP,CAAgBU,WAAhB,EAA6B,EAA7B,CAAvB,CAFuB,CAGvB;;AACAG,IAAAA,MAAM,CAACC,IAAP,CAAYH,IAAI,CAACjB,KAAjB,EACGqB,GADH,CACOhB,MADP,EAEGiB,MAFH,CAEUC,GAAG,IAAIA,GAAG,GAAGL,cAFvB,EAGGM,OAHH,CAGWD,GAAG,IAAI,OAAON,IAAI,CAACjB,KAAL,CAAWuB,GAAX,CAHzB;AAID;;AA3EsB","sourcesContent":["const cacheUtils = require('./cache-utils.js')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e']\n\nmodule.exports = createBlockCacheMiddleware\n\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const { blockTracker } = opts\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy()\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache,\n  }\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next()\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req)\n    const strategy = strategies[type]\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next()\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next()\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req)\n    if (!blockTag) blockTag = 'latest'\n\n    // get exact block number\n    let requestedBlockNumber\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00'\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock()\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber)\n      requestedBlockNumber = latestBlockNumber\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber)\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next()\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result)\n    } else {\n      // fill in result from cache\n      res.result = cacheResult\n    }\n  })\n}\n\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  \n  constructor () {\n    this.cache = {}\n  }\n\n  getBlockCacheForPayload (payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16)\n    let blockCache = this.cache[blockNumber]\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {}\n      this.cache[blockNumber] = newCache\n      blockCache = newCache\n    }\n    return blockCache\n  }\n\n  async get (payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    if (!blockCache) return\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    const cached = blockCache[identifier]\n    // may be undefined\n    return cached\n  }\n\n  async set (payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result)\n    if (!canCache) return\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    blockCache[identifier] = result\n  }\n\n  canCacheRequest (payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload)\n    if (blockTag === 'pending') {\n      return false\n    }\n    // can be cached\n    return true\n  }\n\n  canCacheResult (payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false\n      }\n    }\n    // otherwise true\n    return true\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore (oldBlockHex){\n    const self = this\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)\n    // clear old caches\n    Object.keys(self.cache)\n      .map(Number)\n      .filter(num => num < oldBlockNumber)\n      .forEach(num => delete self.cache[num])\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}