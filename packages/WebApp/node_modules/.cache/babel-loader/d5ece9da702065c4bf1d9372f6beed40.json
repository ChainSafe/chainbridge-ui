{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nvar assert = require(\"assert\");\n\nvar BN = require(\"bn.js\");\n\nvar rlp = require(\"rlp\");\n\nvar ethjs_util_1 = require(\"ethjs-util\");\n\nvar constants_1 = require(\"./constants\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar types_1 = require(\"./types\");\n\nvar _a = require('ethereum-cryptography/secp256k1'),\n    privateKeyVerify = _a.privateKeyVerify,\n    publicKeyCreate = _a.publicKeyCreate,\n    publicKeyVerify = _a.publicKeyVerify,\n    publicKeyConvert = _a.publicKeyConvert;\n\nvar Account =\n/** @class */\nfunction () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new BN(0);\n    }\n\n    if (balance === void 0) {\n      balance = new BN(0);\n    }\n\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n        balance = accountData.balance,\n        stateRoot = accountData.stateRoot,\n        codeHash = accountData.codeHash;\n    return new Account(nonce ? new BN(bytes_1.toBuffer(nonce)) : undefined, balance ? new BN(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n  };\n\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = rlp.decode(serialized);\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  };\n\n  Account.fromValuesArray = function (values) {\n    var nonce = values[0],\n        balance = values[1],\n        stateRoot = values[2],\n        codeHash = values[3];\n    return new Account(nonce ? new BN(nonce) : undefined, balance ? new BN(balance) : undefined, stateRoot, codeHash);\n  };\n\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new BN(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance.lt(new BN(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  Account.prototype.serialize = function () {\n    return rlp.encode([types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash]);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty.\n   * For more details about account emptiness see [EIP-161](https://eips.ethereum.org/EIPS/eip-161).\n   * Note: The stateRoot is also checked to be empty since in Frontier it was possible to create a contract with no code where nonce remained 0 but some values were written to storage in the constructor (thus stateRoot is not KECCAK256_RLP).\n   */\n\n\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.stateRoot.equals(constants_1.KECCAK256_RLP) && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n\n  return Account;\n}();\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nexports.isValidAddress = function (hexAddress) {\n  helpers_1.assertIsHexString(hexAddress);\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\n\n\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  helpers_1.assertIsHexString(hexAddress);\n  var address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccakFromString(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\n\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(nonce);\n  var nonceBN = new BN(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(salt);\n  helpers_1.assertIsBuffer(initCode);\n  assert(from.length === 20);\n  assert(salt.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n  return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  helpers_1.assertIsBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1));\n  }\n\n  assert(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return hash_1.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\n\nexports.privateToPublic = function (privateKey) {\n  helpers_1.assertIsBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from(publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\n\n\nexports.importPublic = function (publicKey) {\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n/**\n * Returns the zero address.\n */\n\n\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\n\n\nexports.isZeroAddress = function (hexAddress) {\n  helpers_1.assertIsHexString(hexAddress);\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === hexAddress;\n};","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nvar assert = require(\"assert\");\nvar BN = require(\"bn.js\");\nvar rlp = require(\"rlp\");\nvar ethjs_util_1 = require(\"ethjs-util\");\nvar constants_1 = require(\"./constants\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nvar _a = require('ethereum-cryptography/secp256k1'), privateKeyVerify = _a.privateKeyVerify, publicKeyCreate = _a.publicKeyCreate, publicKeyVerify = _a.publicKeyVerify, publicKeyConvert = _a.publicKeyConvert;\nvar Account = /** @class */ (function () {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    function Account(nonce, balance, stateRoot, codeHash) {\n        if (nonce === void 0) { nonce = new BN(0); }\n        if (balance === void 0) { balance = new BN(0); }\n        if (stateRoot === void 0) { stateRoot = constants_1.KECCAK256_RLP; }\n        if (codeHash === void 0) { codeHash = constants_1.KECCAK256_NULL; }\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    Account.fromAccountData = function (accountData) {\n        var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;\n        return new Account(nonce ? new BN(bytes_1.toBuffer(nonce)) : undefined, balance ? new BN(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n    };\n    Account.fromRlpSerializedAccount = function (serialized) {\n        var values = rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    };\n    Account.fromValuesArray = function (values) {\n        var nonce = values[0], balance = values[1], stateRoot = values[2], codeHash = values[3];\n        return new Account(nonce ? new BN(nonce) : undefined, balance ? new BN(balance) : undefined, stateRoot, codeHash);\n    };\n    Account.prototype._validate = function () {\n        if (this.nonce.lt(new BN(0))) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance.lt(new BN(0))) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error('stateRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    };\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    Account.prototype.serialize = function () {\n        return rlp.encode([types_1.bnToRlp(this.nonce), types_1.bnToRlp(this.balance), this.stateRoot, this.codeHash]);\n    };\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    Account.prototype.isContract = function () {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    /**\n     * Returns a `Boolean` determining if the account is empty.\n     * For more details about account emptiness see [EIP-161](https://eips.ethereum.org/EIPS/eip-161).\n     * Note: The stateRoot is also checked to be empty since in Frontier it was possible to create a contract with no code where nonce remained 0 but some values were written to storage in the constructor (thus stateRoot is not KECCAK256_RLP).\n     */\n    Account.prototype.isEmpty = function () {\n        return (this.balance.isZero() &&\n            this.nonce.isZero() &&\n            this.stateRoot.equals(constants_1.KECCAK256_RLP) &&\n            this.codeHash.equals(constants_1.KECCAK256_NULL));\n    };\n    return Account;\n}());\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (hexAddress) {\n    helpers_1.assertIsHexString(hexAddress);\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    helpers_1.assertIsHexString(hexAddress);\n    var address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n    var hash = hash_1.keccakFromString(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(nonce);\n    var nonceBN = new BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(salt);\n    helpers_1.assertIsBuffer(initCode);\n    assert(from.length === 20);\n    assert(salt.length === 32);\n    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n    return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    helpers_1.assertIsBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(publicKeyConvert(pubKey, false).slice(1));\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    helpers_1.assertIsBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(publicKeyConvert(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexports.zeroAddress = function () {\n    var addressLength = 20;\n    var addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexports.isZeroAddress = function (hexAddress) {\n    helpers_1.assertIsHexString(hexAddress);\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === hexAddress;\n};\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}