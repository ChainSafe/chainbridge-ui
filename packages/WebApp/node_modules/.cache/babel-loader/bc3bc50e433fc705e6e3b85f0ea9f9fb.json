{"ast":null,"code":"const inherits = require('util').inherits;\n\nconst Transaction = require('ethereumjs-tx');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst Subprovider = require('./subprovider.js');\n\nconst blockTagForPayload = require('../util/rpc-cache-utils').blockTagForPayload;\n\nmodule.exports = NonceTrackerSubprovider; // handles the following RPC methods:\n//   eth_getTransactionCount (pending only)\n//\n// observes the following RPC methods:\n//   eth_sendRawTransaction\n//   evm_revert (to clear the nonce cache)\n\ninherits(NonceTrackerSubprovider, Subprovider);\n\nfunction NonceTrackerSubprovider(opts) {\n  const self = this;\n  self.nonceCache = {};\n}\n\nNonceTrackerSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n\n  switch (payload.method) {\n    case 'eth_getTransactionCount':\n      var blockTag = blockTagForPayload(payload);\n      var address = payload.params[0].toLowerCase();\n      var cachedResult = self.nonceCache[address]; // only handle requests against the 'pending' blockTag\n\n      if (blockTag === 'pending') {\n        // has a result\n        if (cachedResult) {\n          end(null, cachedResult); // fallthrough then populate cache\n        } else {\n          next(function (err, result, cb) {\n            if (err) return cb();\n\n            if (self.nonceCache[address] === undefined) {\n              self.nonceCache[address] = result;\n            }\n\n            cb();\n          });\n        }\n      } else {\n        next();\n      }\n\n      return;\n\n    case 'eth_sendRawTransaction':\n      // allow the request to continue normally\n      next(function (err, result, cb) {\n        // only update local nonce if tx was submitted correctly\n        if (err) return cb(); // parse raw tx\n\n        var rawTx = payload.params[0];\n        var stripped = ethUtil.stripHexPrefix(rawTx);\n        var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex');\n        var tx = new Transaction(Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex')); // extract address\n\n        var address = '0x' + tx.getSenderAddress().toString('hex').toLowerCase(); // extract nonce and increment\n\n        var nonce = ethUtil.bufferToInt(tx.nonce);\n        nonce++; // hexify and normalize\n\n        var hexNonce = nonce.toString(16);\n        if (hexNonce.length % 2) hexNonce = '0' + hexNonce;\n        hexNonce = '0x' + hexNonce; // dont update our record on the nonce until the submit was successful\n        // update cache\n\n        self.nonceCache[address] = hexNonce;\n        cb();\n      });\n      return;\n    // Clear cache on a testrpc revert\n\n    case 'evm_revert':\n      self.nonceCache = {};\n      next();\n      return;\n\n    default:\n      next();\n      return;\n  }\n};","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/web3-provider-engine/subproviders/nonce-tracker.js"],"names":["inherits","require","Transaction","ethUtil","Subprovider","blockTagForPayload","module","exports","NonceTrackerSubprovider","opts","self","nonceCache","prototype","handleRequest","payload","next","end","method","blockTag","address","params","toLowerCase","cachedResult","err","result","cb","undefined","rawTx","stripped","stripHexPrefix","rawData","Buffer","from","tx","getSenderAddress","toString","nonce","bufferToInt","hexNonce","length"],"mappings":"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","sourcesContent":["const inherits = require('util').inherits\nconst Transaction = require('ethereumjs-tx')\nconst ethUtil = require('ethereumjs-util')\nconst Subprovider = require('./subprovider.js')\nconst blockTagForPayload = require('../util/rpc-cache-utils').blockTagForPayload\n\nmodule.exports = NonceTrackerSubprovider\n\n// handles the following RPC methods:\n//   eth_getTransactionCount (pending only)\n//\n// observes the following RPC methods:\n//   eth_sendRawTransaction\n//   evm_revert (to clear the nonce cache)\n\ninherits(NonceTrackerSubprovider, Subprovider)\n\nfunction NonceTrackerSubprovider(opts){\n  const self = this\n\n  self.nonceCache = {}\n}\n\nNonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n\n  switch(payload.method) {\n\n    case 'eth_getTransactionCount':\n      var blockTag = blockTagForPayload(payload)\n      var address = payload.params[0].toLowerCase()\n      var cachedResult = self.nonceCache[address]\n      // only handle requests against the 'pending' blockTag\n      if (blockTag === 'pending') {\n        // has a result\n        if (cachedResult) {\n          end(null, cachedResult)\n        // fallthrough then populate cache\n        } else {\n          next(function(err, result, cb){\n            if (err) return cb()\n            if (self.nonceCache[address] === undefined) {\n              self.nonceCache[address] = result\n            }\n            cb()\n          })\n        }\n      } else {\n        next()\n      }\n      return\n\n    case 'eth_sendRawTransaction':\n      // allow the request to continue normally\n      next(function(err, result, cb){\n        // only update local nonce if tx was submitted correctly\n        if (err) return cb()\n        // parse raw tx\n        var rawTx = payload.params[0]\n        var stripped = ethUtil.stripHexPrefix(rawTx)\n        var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex')\n        var tx = new Transaction(Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex'))\n        // extract address\n        var address = '0x'+tx.getSenderAddress().toString('hex').toLowerCase()\n        // extract nonce and increment\n        var nonce = ethUtil.bufferToInt(tx.nonce)\n        nonce++\n        // hexify and normalize\n        var hexNonce = nonce.toString(16)\n        if (hexNonce.length%2) hexNonce = '0'+hexNonce\n        hexNonce = '0x'+hexNonce\n        // dont update our record on the nonce until the submit was successful\n        // update cache\n        self.nonceCache[address] = hexNonce\n        cb()\n      })\n      return\n\n   // Clear cache on a testrpc revert\n   case 'evm_revert':\n      self.nonceCache = {}\n      next()\n      return\n\n    default:\n      next()\n      return\n\n  }\n}\n"]},"metadata":{},"sourceType":"script"}