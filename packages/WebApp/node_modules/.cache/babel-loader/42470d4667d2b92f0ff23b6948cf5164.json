{"ast":null,"code":"const EthQuery = require('eth-query');\n\nconst pify = require('pify');\n\nconst BaseFilterWithHistory = require('./base-filter-history');\n\nconst {\n  bnToHex,\n  hexToInt,\n  incrementHexInt,\n  minBlockRef,\n  blockRefIsNumber\n} = require('./hexUtils');\n\nclass LogFilter extends BaseFilterWithHistory {\n  constructor({\n    provider,\n    params\n  }) {\n    super();\n    this.type = 'log';\n    this.ethQuery = new EthQuery(provider);\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: []\n    }, params); // normalize address parameter\n\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address];\n      } // ensure lowercase\n\n\n      this.params.address = this.params.address.map(address => address.toLowerCase());\n    }\n  }\n\n  async initialize({\n    currentBlock\n  }) {\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock;\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;\n    if ('earliest' === fromBlock) fromBlock = '0x0';\n    this.params.fromBlock = fromBlock; // set toBlock for initial lookup\n\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock);\n    const params = Object.assign({}, this.params, {\n      toBlock\n    }); // fetch logs and add to results\n\n    const newLogs = await this._fetchLogs(params);\n    this.addInitialResults(newLogs);\n  }\n\n  async update({\n    oldBlock,\n    newBlock\n  }) {\n    // configure params for this update\n    const toBlock = newBlock;\n    let fromBlock; // oldBlock is empty on first sync\n\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock);\n    } else {\n      fromBlock = newBlock;\n    } // fetch logs\n\n\n    const params = Object.assign({}, this.params, {\n      fromBlock,\n      toBlock\n    });\n    const newLogs = await this._fetchLogs(params);\n    const matchingLogs = newLogs.filter(log => this.matchLog(log)); // add to results\n\n    this.addResults(matchingLogs);\n  }\n\n  async _fetchLogs(params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))(); // add to results\n\n    return newLogs;\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false;\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false; // address is correct:\n\n    const normalizedLogAddress = log.address && log.address.toLowerCase();\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false; // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index];\n      if (!logTopic) return false;\n      logTopic = logTopic.toLowerCase(); // normalize subTopics\n\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]; // check for wild card\n\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);\n      if (subtopicsIncludeWildcard) return true;\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase()); // check each possible matching topic\n\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic);\n      return topicDoesMatch;\n    });\n    return topicsMatch;\n  }\n\n}\n\nmodule.exports = LogFilter;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/eth-json-rpc-filters/log-filter.js"],"names":["EthQuery","require","pify","BaseFilterWithHistory","bnToHex","hexToInt","incrementHexInt","minBlockRef","blockRefIsNumber","LogFilter","constructor","provider","params","type","ethQuery","Object","assign","fromBlock","toBlock","address","undefined","topics","Array","isArray","map","toLowerCase","initialize","currentBlock","includes","newLogs","_fetchLogs","addInitialResults","update","oldBlock","newBlock","matchingLogs","filter","log","matchLog","addResults","cb","getLogs","blockNumber","normalizedLogAddress","topicsMatch","every","topicPattern","index","logTopic","subtopicsToMatch","subtopicsIncludeWildcard","topic","topicDoesMatch","module","exports"],"mappings":"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","sourcesContent":["const EthQuery = require('eth-query')\nconst pify = require('pify')\nconst BaseFilterWithHistory = require('./base-filter-history')\nconst { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require('./hexUtils')\n\nclass LogFilter extends BaseFilterWithHistory {\n\n  constructor ({ provider, params }) {\n    super()\n    this.type = 'log'\n    this.ethQuery = new EthQuery(provider)\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: [],\n    }, params)\n    // normalize address parameter\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address]\n      }\n      // ensure lowercase\n      this.params.address = this.params.address.map(address => address.toLowerCase())\n    }\n  }\n\n  async initialize({ currentBlock }) {\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock\n    if ('earliest' === fromBlock) fromBlock = '0x0'\n    this.params.fromBlock = fromBlock\n    // set toBlock for initial lookup\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock)\n    const params = Object.assign({}, this.params, { toBlock })\n    // fetch logs and add to results\n    const newLogs = await this._fetchLogs(params)\n    this.addInitialResults(newLogs)\n  }\n\n  async update ({ oldBlock, newBlock }) {\n    // configure params for this update\n    const toBlock = newBlock\n    let fromBlock\n    // oldBlock is empty on first sync\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock)\n    } else {\n      fromBlock = newBlock\n    }\n    // fetch logs\n    const params = Object.assign({}, this.params, { fromBlock, toBlock })\n    const newLogs = await this._fetchLogs(params)\n    const matchingLogs = newLogs.filter(log => this.matchLog(log))\n\n    // add to results\n    this.addResults(matchingLogs)\n  }\n\n  async _fetchLogs (params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))()\n    // add to results\n    return newLogs\n  }\n\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false\n\n    // address is correct:\n    const normalizedLogAddress = log.address && log.address.toLowerCase()\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false\n\n    // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index]\n      if (!logTopic) return false\n      logTopic = logTopic.toLowerCase()\n      // normalize subTopics\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]\n      // check for wild card\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null)\n      if (subtopicsIncludeWildcard) return true\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase())\n      // check each possible matching topic\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic)\n      return topicDoesMatch\n    })\n\n    return topicsMatch\n  }\n\n}\n\nmodule.exports = LogFilter\n"]},"metadata":{},"sourceType":"script"}