{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorCodes = require(\"./errorCodes\");\n\nvar _createDestructor2 = _interopRequireDefault(require(\"./createDestructor\"));\n\nvar _getOriginFromSrc = _interopRequireDefault(require(\"./getOriginFromSrc\"));\n\nvar _createLogger = _interopRequireDefault(require(\"./createLogger\"));\n\nvar _connectCallReceiver = _interopRequireDefault(require(\"./connectCallReceiver\"));\n\nvar _connectCallSender = _interopRequireDefault(require(\"./connectCallSender\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {Function} destroy A method that, when called, will disconnect any\n * messaging channels. You may call this even before a connection has been established.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {HTMLIframeElement} options.iframe The iframe to connect to.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {String} [options.childOrigin] The child origin to use to secure communication. If\n * not provided, the child origin will be derived from the iframe's src or srcdoc value.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\n\nvar _default = _ref => {\n  let iframe = _ref.iframe,\n      _ref$methods = _ref.methods,\n      methods = _ref$methods === void 0 ? {} : _ref$methods,\n      childOrigin = _ref.childOrigin,\n      timeout = _ref.timeout,\n      debug = _ref.debug;\n  const log = (0, _createLogger.default)(debug);\n  const parent = window;\n\n  const _createDestructor = (0, _createDestructor2.default)(),\n        destroy = _createDestructor.destroy,\n        onDestroy = _createDestructor.onDestroy;\n\n  if (!childOrigin) {\n    if (!iframe.src && !iframe.srcdoc) {\n      const error = new Error('Iframe must have src or srcdoc property defined.');\n      error.code = _errorCodes.ERR_NO_IFRAME_SRC;\n      throw error;\n    }\n\n    childOrigin = (0, _getOriginFromSrc.default)(iframe.src);\n  } // If event.origin is \"null\", the remote protocol is\n  // file:, data:, and we must post messages with \"*\" as targetOrigin\n  // when sending and allow\n  // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n\n\n  const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  const promise = new Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(`Connection to child timed out after ${timeout}ms`);\n        error.code = _errorCodes.ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    } // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n\n\n    const callSender = {};\n    let receiverMethodNames;\n    let destroyCallReceiver;\n\n    const handleMessage = event => {\n      const child = iframe.contentWindow;\n\n      if (event.source !== child || event.data.penpal !== _constants.HANDSHAKE) {\n        return;\n      }\n\n      if (event.origin !== childOrigin) {\n        log(`Parent received handshake from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n        return;\n      }\n\n      log('Parent: Received handshake, sending reply');\n      event.source.postMessage({\n        penpal: _constants.HANDSHAKE_REPLY,\n        methodNames: Object.keys(methods)\n      }, originForSending);\n      const info = {\n        localName: 'Parent',\n        local: parent,\n        remote: child,\n        originForSending: originForSending,\n        originForReceiving: childOrigin\n      }; // If the child reconnected, we need to destroy the previous call receiver before setting\n      // up a new one.\n\n      if (destroyCallReceiver) {\n        destroyCallReceiver();\n      }\n\n      destroyCallReceiver = (0, _connectCallReceiver.default)(info, methods, log);\n      onDestroy(destroyCallReceiver); // If the child reconnected, we need to remove the methods from the previous call receiver\n      // off the sender.\n\n      if (receiverMethodNames) {\n        receiverMethodNames.forEach(receiverMethodName => {\n          delete callSender[receiverMethodName];\n        });\n      }\n\n      receiverMethodNames = event.data.methodNames;\n      const destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);\n      onDestroy(destroyCallSender);\n      clearTimeout(connectionTimeoutId);\n      resolveConnectionPromise(callSender);\n    };\n\n    parent.addEventListener(_constants.MESSAGE, handleMessage);\n    log('Parent: Awaiting handshake'); // This is to prevent memory leaks when the iframe is removed\n    // from the document and the consumer hasn't called destroy().\n    // Without this, event listeners attached to the window would\n    // stick around and since the event handlers have a reference\n    // to the iframe in their closures, the iframe would stick around\n    // too.\n\n    var checkIframeInDocIntervalId = setInterval(() => {\n      if (!document.contains(iframe)) {\n        clearInterval(checkIframeInDocIntervalId);\n        destroy();\n      }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n      parent.removeEventListener(_constants.MESSAGE, handleMessage);\n      clearInterval(checkIframeInDocIntervalId);\n      const error = new Error('Connection destroyed');\n      error.code = _errorCodes.ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n  });\n  return {\n    promise,\n    destroy\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/authereum/node_modules/penpal/lib/connectToChild.js"],"names":["Object","defineProperty","exports","value","default","_constants","require","_errorCodes","_createDestructor2","_interopRequireDefault","_getOriginFromSrc","_createLogger","_connectCallReceiver","_connectCallSender","obj","__esModule","CHECK_IFRAME_IN_DOC_INTERVAL","_default","_ref","iframe","_ref$methods","methods","childOrigin","timeout","debug","log","parent","window","_createDestructor","destroy","onDestroy","src","srcdoc","error","Error","code","ERR_NO_IFRAME_SRC","originForSending","promise","Promise","resolveConnectionPromise","reject","connectionTimeoutId","undefined","setTimeout","ERR_CONNECTION_TIMEOUT","callSender","receiverMethodNames","destroyCallReceiver","handleMessage","event","child","contentWindow","source","data","penpal","HANDSHAKE","origin","postMessage","HANDSHAKE_REPLY","methodNames","keys","info","localName","local","remote","originForReceiving","forEach","receiverMethodName","destroyCallSender","clearTimeout","addEventListener","MESSAGE","checkIframeInDocIntervalId","setInterval","document","contains","clearInterval","removeEventListener","ERR_CONNECTION_DESTROYED","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorCodes = require(\"./errorCodes\");\n\nvar _createDestructor2 = _interopRequireDefault(require(\"./createDestructor\"));\n\nvar _getOriginFromSrc = _interopRequireDefault(require(\"./getOriginFromSrc\"));\n\nvar _createLogger = _interopRequireDefault(require(\"./createLogger\"));\n\nvar _connectCallReceiver = _interopRequireDefault(require(\"./connectCallReceiver\"));\n\nvar _connectCallSender = _interopRequireDefault(require(\"./connectCallSender\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {Function} destroy A method that, when called, will disconnect any\n * messaging channels. You may call this even before a connection has been established.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {HTMLIframeElement} options.iframe The iframe to connect to.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {String} [options.childOrigin] The child origin to use to secure communication. If\n * not provided, the child origin will be derived from the iframe's src or srcdoc value.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\n\nvar _default = (_ref) => {\n  let iframe = _ref.iframe,\n      _ref$methods = _ref.methods,\n      methods = _ref$methods === void 0 ? {} : _ref$methods,\n      childOrigin = _ref.childOrigin,\n      timeout = _ref.timeout,\n      debug = _ref.debug;\n  const log = (0, _createLogger.default)(debug);\n  const parent = window;\n\n  const _createDestructor = (0, _createDestructor2.default)(),\n        destroy = _createDestructor.destroy,\n        onDestroy = _createDestructor.onDestroy;\n\n  if (!childOrigin) {\n    if (!iframe.src && !iframe.srcdoc) {\n      const error = new Error('Iframe must have src or srcdoc property defined.');\n      error.code = _errorCodes.ERR_NO_IFRAME_SRC;\n      throw error;\n    }\n\n    childOrigin = (0, _getOriginFromSrc.default)(iframe.src);\n  } // If event.origin is \"null\", the remote protocol is\n  // file:, data:, and we must post messages with \"*\" as targetOrigin\n  // when sending and allow\n  // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n\n\n  const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  const promise = new Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(`Connection to child timed out after ${timeout}ms`);\n        error.code = _errorCodes.ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    } // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n\n\n    const callSender = {};\n    let receiverMethodNames;\n    let destroyCallReceiver;\n\n    const handleMessage = event => {\n      const child = iframe.contentWindow;\n\n      if (event.source !== child || event.data.penpal !== _constants.HANDSHAKE) {\n        return;\n      }\n\n      if (event.origin !== childOrigin) {\n        log(`Parent received handshake from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n        return;\n      }\n\n      log('Parent: Received handshake, sending reply');\n      event.source.postMessage({\n        penpal: _constants.HANDSHAKE_REPLY,\n        methodNames: Object.keys(methods)\n      }, originForSending);\n      const info = {\n        localName: 'Parent',\n        local: parent,\n        remote: child,\n        originForSending: originForSending,\n        originForReceiving: childOrigin\n      }; // If the child reconnected, we need to destroy the previous call receiver before setting\n      // up a new one.\n\n      if (destroyCallReceiver) {\n        destroyCallReceiver();\n      }\n\n      destroyCallReceiver = (0, _connectCallReceiver.default)(info, methods, log);\n      onDestroy(destroyCallReceiver); // If the child reconnected, we need to remove the methods from the previous call receiver\n      // off the sender.\n\n      if (receiverMethodNames) {\n        receiverMethodNames.forEach(receiverMethodName => {\n          delete callSender[receiverMethodName];\n        });\n      }\n\n      receiverMethodNames = event.data.methodNames;\n      const destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);\n      onDestroy(destroyCallSender);\n      clearTimeout(connectionTimeoutId);\n      resolveConnectionPromise(callSender);\n    };\n\n    parent.addEventListener(_constants.MESSAGE, handleMessage);\n    log('Parent: Awaiting handshake'); // This is to prevent memory leaks when the iframe is removed\n    // from the document and the consumer hasn't called destroy().\n    // Without this, event listeners attached to the window would\n    // stick around and since the event handlers have a reference\n    // to the iframe in their closures, the iframe would stick around\n    // too.\n\n    var checkIframeInDocIntervalId = setInterval(() => {\n      if (!document.contains(iframe)) {\n        clearInterval(checkIframeInDocIntervalId);\n        destroy();\n      }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n      parent.removeEventListener(_constants.MESSAGE, handleMessage);\n      clearInterval(checkIframeInDocIntervalId);\n      const error = new Error('Connection destroyed');\n      error.code = _errorCodes.ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n  });\n  return {\n    promise,\n    destroy\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}