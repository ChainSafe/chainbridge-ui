{"ast":null,"code":"const ethUtil = require('ethereumjs-util');\n\nconst ethAbi = require('ethereumjs-abi');\n\nmodule.exports = {\n  concatSig: function (v, r, s) {\n    const rSig = ethUtil.fromSigned(r);\n    const sSig = ethUtil.fromSigned(s);\n    const vSig = ethUtil.bufferToInt(v);\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n  },\n  normalize: function (input) {\n    if (!input) return;\n\n    if (typeof input === 'number') {\n      const buffer = ethUtil.toBuffer(input);\n      input = ethUtil.bufferToHex(buffer);\n    }\n\n    if (typeof input !== 'string') {\n      var msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n      msg += ' received ' + typeof input + ': ' + input;\n      throw new Error(msg);\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase());\n  },\n  personalSign: function (privateKey, msgParams) {\n    var message = ethUtil.toBuffer(msgParams.data);\n    var msgHash = ethUtil.hashPersonalMessage(message);\n    var sig = ethUtil.ecsign(msgHash, privateKey);\n    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n    return serialized;\n  },\n  recoverPersonalSignature: function (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    const sender = ethUtil.publicToAddress(publicKey);\n    const senderHex = ethUtil.bufferToHex(sender);\n    return senderHex;\n  },\n  extractPublicKey: function (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    return '0x' + publicKey.toString('hex');\n  },\n  typedSignatureHash: function (typedData) {\n    const hashBuffer = typedSignatureHash(typedData);\n    return ethUtil.bufferToHex(hashBuffer);\n  },\n  signTypedData: function (privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const sig = ethUtil.ecsign(msgHash, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignature: function (msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  }\n};\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\n\nfunction typedSignatureHash(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n  if (typeof typedData !== 'object' || !typedData.length) throw error;\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error;\n    return e.type + ' ' + e.name;\n  });\n  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);\n}\n\nfunction recoverPublicKey(hash, sig) {\n  const signature = ethUtil.toBuffer(sig);\n  const sigParams = ethUtil.fromRpcSig(signature);\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\n\nfunction getPublicKeyFor(msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data);\n  const msgHash = ethUtil.hashPersonalMessage(message);\n  return recoverPublicKey(msgHash, msgParams.sig);\n}\n\nfunction padWithZeroes(number, length) {\n  var myString = '' + number;\n\n  while (myString.length < length) {\n    myString = '0' + myString;\n  }\n\n  return myString;\n}","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/eth-sig-util/index.js"],"names":["ethUtil","require","ethAbi","module","exports","concatSig","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","padWithZeroes","toUnsigned","toString","sStr","vStr","stripHexPrefix","intToHex","addHexPrefix","concat","normalize","input","buffer","toBuffer","bufferToHex","msg","Error","toLowerCase","personalSign","privateKey","msgParams","message","data","msgHash","hashPersonalMessage","sig","ecsign","serialized","recoverPersonalSignature","publicKey","getPublicKeyFor","sender","publicToAddress","senderHex","extractPublicKey","typedSignatureHash","typedData","hashBuffer","signTypedData","recoverTypedSignature","recoverPublicKey","error","length","map","e","type","value","types","schema","name","soliditySHA3","Array","fill","hash","signature","sigParams","fromRpcSig","ecrecover","number","myString"],"mappings":"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","sourcesContent":["const ethUtil = require('ethereumjs-util')\nconst ethAbi = require('ethereumjs-abi')\n\nmodule.exports = {\n\n  concatSig: function (v, r, s) {\n    const rSig = ethUtil.fromSigned(r)\n    const sSig = ethUtil.fromSigned(s)\n    const vSig = ethUtil.bufferToInt(v)\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')\n  },\n\n  normalize: function (input) {\n    if (!input) return\n\n    if (typeof input === 'number') {\n      const buffer = ethUtil.toBuffer(input)\n      input = ethUtil.bufferToHex(buffer)\n    }\n\n    if (typeof input !== 'string') {\n      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'\n      msg += ' received ' + (typeof input) + ': ' + input\n      throw new Error(msg)\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase())\n  },\n\n  personalSign: function (privateKey, msgParams) {\n    var message = ethUtil.toBuffer(msgParams.data)\n    var msgHash = ethUtil.hashPersonalMessage(message)\n    var sig = ethUtil.ecsign(msgHash, privateKey)\n    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n    return serialized\n  },\n\n  recoverPersonalSignature: function (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams)\n    const sender = ethUtil.publicToAddress(publicKey)\n    const senderHex = ethUtil.bufferToHex(sender)\n    return senderHex\n  },\n\n  extractPublicKey: function (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams)\n    return '0x' + publicKey.toString('hex')\n  },\n\n  typedSignatureHash: function (typedData) {\n    const hashBuffer = typedSignatureHash(typedData)\n    return ethUtil.bufferToHex(hashBuffer)\n  },\n\n  signTypedData: function (privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data)\n    const sig = ethUtil.ecsign(msgHash, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  recoverTypedSignature: function (msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data)\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  }\n\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHash(typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) throw error\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) { return e.type })\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error\n    return e.type + ' ' + e.name\n  })\n\n  return ethAbi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      ethAbi.soliditySHA3(types, data)\n    ]\n  )\n}\n\nfunction recoverPublicKey(hash, sig) {\n  const signature = ethUtil.toBuffer(sig)\n  const sigParams = ethUtil.fromRpcSig(signature)\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)\n}\n\nfunction getPublicKeyFor (msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data)\n  const msgHash = ethUtil.hashPersonalMessage(message)\n  return recoverPublicKey(msgHash, msgParams.sig)\n}\n\n\nfunction padWithZeroes (number, length) {\n  var myString = '' + number\n  while (myString.length < length) {\n    myString = '0' + myString\n  }\n  return myString\n}\n"]},"metadata":{},"sourceType":"script"}