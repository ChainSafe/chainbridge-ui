{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst env_1 = require(\"./lib/env\");\n\nconst secp256k1_1 = require(\"./lib/secp256k1\");\n\nconst elliptic_1 = require(\"./lib/elliptic\");\n\nconst constants_1 = require(\"./constants\");\n\nconst helpers_1 = require(\"./helpers\");\n\nfunction generatePrivate() {\n  return env_1.isNode() ? secp256k1_1.secp256k1GeneratePrivate() : elliptic_1.ellipticGeneratePrivate();\n}\n\nexports.generatePrivate = generatePrivate;\n\nfunction checkPrivateKey(privateKey) {\n  helpers_1.assert(privateKey.length === constants_1.KEY_LENGTH, constants_1.ERROR_BAD_PRIVATE_KEY);\n  helpers_1.assert(helpers_1.isValidPrivateKey(privateKey), constants_1.ERROR_BAD_PRIVATE_KEY);\n}\n\nexports.checkPrivateKey = checkPrivateKey;\n\nfunction checkPublicKey(publicKey) {\n  helpers_1.assert(publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH || publicKey.length === constants_1.PREFIXED_KEY_LENGTH, constants_1.ERROR_BAD_PUBLIC_KEY);\n\n  if (publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH) {\n    helpers_1.assert(publicKey[0] === 4, constants_1.ERROR_BAD_PUBLIC_KEY);\n  }\n\n  if (publicKey.length === constants_1.PREFIXED_KEY_LENGTH) {\n    helpers_1.assert(publicKey[0] === 2 || publicKey[0] === 3, constants_1.ERROR_BAD_PUBLIC_KEY);\n  }\n}\n\nexports.checkPublicKey = checkPublicKey;\n\nfunction checkMessage(msg) {\n  helpers_1.assert(msg.length > 0, constants_1.ERROR_EMPTY_MESSAGE);\n  helpers_1.assert(msg.length <= constants_1.MAX_MSG_LENGTH, constants_1.ERROR_MESSAGE_TOO_LONG);\n}\n\nexports.checkMessage = checkMessage;\n\nfunction compress(publicKey) {\n  if (helpers_1.isCompressed(publicKey)) {\n    return publicKey;\n  }\n\n  return env_1.isNode() ? secp256k1_1.secp256k1Compress(publicKey) : elliptic_1.ellipticCompress(publicKey);\n}\n\nexports.compress = compress;\n\nfunction decompress(publicKey) {\n  if (helpers_1.isDecompressed(publicKey)) {\n    return publicKey;\n  }\n\n  return env_1.isNode() ? secp256k1_1.secp256k1Decompress(publicKey) : elliptic_1.ellipticDecompress(publicKey);\n}\n\nexports.decompress = decompress;\n\nfunction getPublic(privateKey) {\n  checkPrivateKey(privateKey);\n  return env_1.isNode() ? secp256k1_1.secp256k1GetPublic(privateKey) : elliptic_1.ellipticGetPublic(privateKey);\n}\n\nexports.getPublic = getPublic;\n\nfunction getPublicCompressed(privateKey) {\n  checkPrivateKey(privateKey);\n  return env_1.isNode() ? secp256k1_1.secp256k1GetPublicCompressed(privateKey) : elliptic_1.ellipticGetPublicCompressed(privateKey);\n}\n\nexports.getPublicCompressed = getPublicCompressed;\n\nfunction generateKeyPair() {\n  const privateKey = generatePrivate();\n  const publicKey = getPublic(privateKey);\n  return {\n    privateKey,\n    publicKey\n  };\n}\n\nexports.generateKeyPair = generateKeyPair;\n\nfunction signatureExport(sig) {\n  return env_1.isNode() ? secp256k1_1.secp256k1SignatureExport(sig) : elliptic_1.ellipticSignatureExport(sig);\n}\n\nexports.signatureExport = signatureExport;\n\nfunction sign(privateKey, msg, rsvSig = false) {\n  checkPrivateKey(privateKey);\n  checkMessage(msg);\n  return env_1.isNode() ? secp256k1_1.secp256k1Sign(msg, privateKey, rsvSig) : elliptic_1.ellipticSign(msg, privateKey, rsvSig);\n}\n\nexports.sign = sign;\n\nfunction recover(msg, sig, compressed = false) {\n  checkMessage(msg);\n  return env_1.isNode() ? secp256k1_1.secp256k1Recover(sig, msg, compressed) : elliptic_1.ellipticRecover(sig, msg, compressed);\n}\n\nexports.recover = recover;\n\nfunction verify(publicKey, msg, sig) {\n  checkPublicKey(publicKey);\n  checkMessage(msg);\n  const sigGood = env_1.isNode() ? secp256k1_1.secp256k1Verify(sig, msg, publicKey) : elliptic_1.ellipticVerify(sig, msg, publicKey);\n\n  if (sigGood) {\n    return null;\n  } else {\n    throw new Error('Bad signature');\n  }\n}\n\nexports.verify = verify;","map":{"version":3,"sources":["../../src/ecdsa.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst env_1 = require(\"./lib/env\");\nconst secp256k1_1 = require(\"./lib/secp256k1\");\nconst elliptic_1 = require(\"./lib/elliptic\");\nconst constants_1 = require(\"./constants\");\nconst helpers_1 = require(\"./helpers\");\nfunction generatePrivate() {\n    return env_1.isNode() ? secp256k1_1.secp256k1GeneratePrivate() : elliptic_1.ellipticGeneratePrivate();\n}\nexports.generatePrivate = generatePrivate;\nfunction checkPrivateKey(privateKey) {\n    helpers_1.assert(privateKey.length === constants_1.KEY_LENGTH, constants_1.ERROR_BAD_PRIVATE_KEY);\n    helpers_1.assert(helpers_1.isValidPrivateKey(privateKey), constants_1.ERROR_BAD_PRIVATE_KEY);\n}\nexports.checkPrivateKey = checkPrivateKey;\nfunction checkPublicKey(publicKey) {\n    helpers_1.assert(publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH ||\n        publicKey.length === constants_1.PREFIXED_KEY_LENGTH, constants_1.ERROR_BAD_PUBLIC_KEY);\n    if (publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH) {\n        helpers_1.assert(publicKey[0] === 4, constants_1.ERROR_BAD_PUBLIC_KEY);\n    }\n    if (publicKey.length === constants_1.PREFIXED_KEY_LENGTH) {\n        helpers_1.assert(publicKey[0] === 2 || publicKey[0] === 3, constants_1.ERROR_BAD_PUBLIC_KEY);\n    }\n}\nexports.checkPublicKey = checkPublicKey;\nfunction checkMessage(msg) {\n    helpers_1.assert(msg.length > 0, constants_1.ERROR_EMPTY_MESSAGE);\n    helpers_1.assert(msg.length <= constants_1.MAX_MSG_LENGTH, constants_1.ERROR_MESSAGE_TOO_LONG);\n}\nexports.checkMessage = checkMessage;\nfunction compress(publicKey) {\n    if (helpers_1.isCompressed(publicKey)) {\n        return publicKey;\n    }\n    return env_1.isNode() ? secp256k1_1.secp256k1Compress(publicKey) : elliptic_1.ellipticCompress(publicKey);\n}\nexports.compress = compress;\nfunction decompress(publicKey) {\n    if (helpers_1.isDecompressed(publicKey)) {\n        return publicKey;\n    }\n    return env_1.isNode()\n        ? secp256k1_1.secp256k1Decompress(publicKey)\n        : elliptic_1.ellipticDecompress(publicKey);\n}\nexports.decompress = decompress;\nfunction getPublic(privateKey) {\n    checkPrivateKey(privateKey);\n    return env_1.isNode()\n        ? secp256k1_1.secp256k1GetPublic(privateKey)\n        : elliptic_1.ellipticGetPublic(privateKey);\n}\nexports.getPublic = getPublic;\nfunction getPublicCompressed(privateKey) {\n    checkPrivateKey(privateKey);\n    return env_1.isNode()\n        ? secp256k1_1.secp256k1GetPublicCompressed(privateKey)\n        : elliptic_1.ellipticGetPublicCompressed(privateKey);\n}\nexports.getPublicCompressed = getPublicCompressed;\nfunction generateKeyPair() {\n    const privateKey = generatePrivate();\n    const publicKey = getPublic(privateKey);\n    return { privateKey, publicKey };\n}\nexports.generateKeyPair = generateKeyPair;\nfunction signatureExport(sig) {\n    return env_1.isNode()\n        ? secp256k1_1.secp256k1SignatureExport(sig)\n        : elliptic_1.ellipticSignatureExport(sig);\n}\nexports.signatureExport = signatureExport;\nfunction sign(privateKey, msg, rsvSig = false) {\n    checkPrivateKey(privateKey);\n    checkMessage(msg);\n    return env_1.isNode()\n        ? secp256k1_1.secp256k1Sign(msg, privateKey, rsvSig)\n        : elliptic_1.ellipticSign(msg, privateKey, rsvSig);\n}\nexports.sign = sign;\nfunction recover(msg, sig, compressed = false) {\n    checkMessage(msg);\n    return env_1.isNode()\n        ? secp256k1_1.secp256k1Recover(sig, msg, compressed)\n        : elliptic_1.ellipticRecover(sig, msg, compressed);\n}\nexports.recover = recover;\nfunction verify(publicKey, msg, sig) {\n    checkPublicKey(publicKey);\n    checkMessage(msg);\n    const sigGood = env_1.isNode()\n        ? secp256k1_1.secp256k1Verify(sig, msg, publicKey)\n        : elliptic_1.ellipticVerify(sig, msg, publicKey);\n    if (sigGood) {\n        return null;\n    }\n    else {\n        throw new Error('Bad signature');\n    }\n}\nexports.verify = verify;\n//# sourceMappingURL=ecdsa.js.map"]},"metadata":{},"sourceType":"script"}