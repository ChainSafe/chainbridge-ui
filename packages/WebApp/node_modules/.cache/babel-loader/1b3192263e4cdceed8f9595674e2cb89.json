{"ast":null,"code":"var BufferUtil = require('../utils/buffer');\n\nvar Utils = require('./utils');\n\nvar ECLevel = require('./error-correction-level');\n\nvar BitBuffer = require('./bit-buffer');\n\nvar BitMatrix = require('./bit-matrix');\n\nvar AlignmentPattern = require('./alignment-pattern');\n\nvar FinderPattern = require('./finder-pattern');\n\nvar MaskPattern = require('./mask-pattern');\n\nvar ECCode = require('./error-correction-code');\n\nvar ReedSolomonEncoder = require('./reed-solomon-encoder');\n\nvar Version = require('./version');\n\nvar FormatInfo = require('./format-info');\n\nvar Mode = require('./mode');\n\nvar Segments = require('./segments');\n\nvar isArray = require('isarray');\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupFinderPattern(matrix, version) {\n  var size = matrix.size;\n  var pos = FinderPattern.getPositions(version);\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0];\n    var col = pos[i][1];\n\n    for (var r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue;\n\n      for (var c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue;\n\n        if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\n\n\nfunction setupTimingPattern(matrix) {\n  var size = matrix.size;\n\n  for (var r = 8; r < size - 8; r++) {\n    var value = r % 2 === 0;\n    matrix.set(r, 6, value, true);\n    matrix.set(6, r, value, true);\n  }\n}\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupAlignmentPattern(matrix, version) {\n  var pos = AlignmentPattern.getPositions(version);\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0];\n    var col = pos[i][1];\n\n    for (var r = -2; r <= 2; r++) {\n      for (var c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n          matrix.set(row + r, col + c, true, true);\n        } else {\n          matrix.set(row + r, col + c, false, true);\n        }\n      }\n    }\n  }\n}\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\n\n\nfunction setupVersionInfo(matrix, version) {\n  var size = matrix.size;\n  var bits = Version.getEncodedBits(version);\n  var row, col, mod;\n\n  for (var i = 0; i < 18; i++) {\n    row = Math.floor(i / 3);\n    col = i % 3 + size - 8 - 3;\n    mod = (bits >> i & 1) === 1;\n    matrix.set(row, col, mod, true);\n    matrix.set(col, row, mod, true);\n  }\n}\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\n\n\nfunction setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n  var size = matrix.size;\n  var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n  var i, mod;\n\n  for (i = 0; i < 15; i++) {\n    mod = (bits >> i & 1) === 1; // vertical\n\n    if (i < 6) {\n      matrix.set(i, 8, mod, true);\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true);\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true);\n    } // horizontal\n\n\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true);\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true);\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true);\n    }\n  } // fixed module\n\n\n  matrix.set(size - 8, 8, 1, true);\n}\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\n\n\nfunction setupData(matrix, data) {\n  var size = matrix.size;\n  var inc = -1;\n  var row = size - 1;\n  var bitIndex = 7;\n  var byteIndex = 0;\n\n  for (var col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--;\n\n    while (true) {\n      for (var c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          var dark = false;\n\n          if (byteIndex < data.length) {\n            dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n          }\n\n          matrix.set(row, col - c, dark);\n          bitIndex--;\n\n          if (bitIndex === -1) {\n            byteIndex++;\n            bitIndex = 7;\n          }\n        }\n      }\n\n      row += inc;\n\n      if (row < 0 || size <= row) {\n        row -= inc;\n        inc = -inc;\n        break;\n      }\n    }\n  }\n}\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\n\n\nfunction createData(version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  var buffer = new BitBuffer();\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4); // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version)); // add binary data sequence to buffer\n\n    data.write(buffer);\n  }); // Calculate required number of bits\n\n  var totalCodewords = Utils.getSymbolTotalCodewords(version);\n  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8; // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4);\n  } // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n\n\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0);\n  } // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n\n\n  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n\n  for (var i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel);\n}\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\n\n\nfunction createCodewords(bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  var totalCodewords = Utils.getSymbolTotalCodewords(version); // Total number of error correction codewords\n\n  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords\n\n  var dataTotalCodewords = totalCodewords - ecTotalCodewords; // Total number of blocks\n\n  var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel); // Calculate how many blocks each group should contain\n\n  var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1; // Number of EC codewords is the same for both groups\n\n  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1; // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n\n  var rs = new ReedSolomonEncoder(ecCount);\n  var offset = 0;\n  var dcData = new Array(ecTotalBlocks);\n  var ecData = new Array(ecTotalBlocks);\n  var maxDataSize = 0;\n  var buffer = BufferUtil.from(bitBuffer.buffer); // Divide the buffer into the required number of blocks\n\n  for (var b = 0; b < ecTotalBlocks; b++) {\n    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2; // extract a block of data from buffer\n\n    dcData[b] = buffer.slice(offset, offset + dataSize); // Calculate EC codewords for this data block\n\n    ecData[b] = rs.encode(dcData[b]);\n    offset += dataSize;\n    maxDataSize = Math.max(maxDataSize, dataSize);\n  } // Create final data\n  // Interleave the data and error correction codewords from each block\n\n\n  var data = BufferUtil.alloc(totalCodewords);\n  var index = 0;\n  var i, r; // Add data codewords\n\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i];\n      }\n    }\n  } // Apped EC codewords\n\n\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i];\n    }\n  }\n\n  return data;\n}\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\n\n\nfunction createSymbol(data, version, errorCorrectionLevel, maskPattern) {\n  var segments;\n\n  if (isArray(data)) {\n    segments = Segments.fromArray(data);\n  } else if (typeof data === 'string') {\n    var estimatedVersion = version;\n\n    if (!estimatedVersion) {\n      var rawSegments = Segments.rawSplit(data); // Estimate best version that can contain raw splitted segments\n\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n    } // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n\n\n    segments = Segments.fromString(data, estimatedVersion || 40);\n  } else {\n    throw new Error('Invalid data');\n  } // Get the min version that can contain data\n\n\n  var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel); // If no version is found, data cannot be stored\n\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code');\n  } // If not specified, use min version as default\n\n\n  if (!version) {\n    version = bestVersion; // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' + 'The chosen QR Code version cannot contain this amount of data.\\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n  }\n\n  var dataBits = createData(version, errorCorrectionLevel, segments); // Allocate matrix buffer\n\n  var moduleCount = Utils.getSymbolSize(version);\n  var modules = new BitMatrix(moduleCount); // Add function modules\n\n  setupFinderPattern(modules, version);\n  setupTimingPattern(modules);\n  setupAlignmentPattern(modules, version); // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n\n  setupFormatInfo(modules, errorCorrectionLevel, 0);\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version);\n  } // Add data codewords\n\n\n  setupData(modules, dataBits);\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n  } // Apply mask pattern\n\n\n  MaskPattern.applyMask(maskPattern, modules); // Replace format info bits with correct values\n\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern);\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  };\n}\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\n\n\nexports.create = function create(data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text');\n  }\n\n  var errorCorrectionLevel = ECLevel.M;\n  var version;\n  var mask;\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);\n    version = Version.from(options.version);\n    mask = MaskPattern.from(options.maskPattern);\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc);\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask);\n};","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/qrcode/lib/core/qrcode.js"],"names":["BufferUtil","require","Utils","ECLevel","BitBuffer","BitMatrix","AlignmentPattern","FinderPattern","MaskPattern","ECCode","ReedSolomonEncoder","Version","FormatInfo","Mode","Segments","isArray","setupFinderPattern","matrix","version","size","pos","getPositions","i","length","row","col","r","c","set","setupTimingPattern","value","setupAlignmentPattern","setupVersionInfo","bits","getEncodedBits","mod","Math","floor","setupFormatInfo","errorCorrectionLevel","maskPattern","setupData","data","inc","bitIndex","byteIndex","isReserved","dark","createData","segments","buffer","forEach","put","mode","bit","getLength","getCharCountIndicator","write","totalCodewords","getSymbolTotalCodewords","ecTotalCodewords","getTotalCodewordsCount","dataTotalCodewordsBits","getLengthInBits","putBit","remainingByte","createCodewords","bitBuffer","dataTotalCodewords","ecTotalBlocks","getBlocksCount","blocksInGroup2","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","rs","offset","dcData","Array","ecData","maxDataSize","from","b","dataSize","slice","encode","max","alloc","index","createSymbol","fromArray","estimatedVersion","rawSegments","rawSplit","getBestVersionForData","fromString","Error","bestVersion","dataBits","moduleCount","getSymbolSize","modules","isNaN","getBestMask","bind","applyMask","exports","create","options","M","mask","toSJISFunc","setToSJISFunction"],"mappings":"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","sourcesContent":["var BufferUtil = require('../utils/buffer')\nvar Utils = require('./utils')\nvar ECLevel = require('./error-correction-level')\nvar BitBuffer = require('./bit-buffer')\nvar BitMatrix = require('./bit-matrix')\nvar AlignmentPattern = require('./alignment-pattern')\nvar FinderPattern = require('./finder-pattern')\nvar MaskPattern = require('./mask-pattern')\nvar ECCode = require('./error-correction-code')\nvar ReedSolomonEncoder = require('./reed-solomon-encoder')\nvar Version = require('./version')\nvar FormatInfo = require('./format-info')\nvar Mode = require('./mode')\nvar Segments = require('./segments')\nvar isArray = require('isarray')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  var size = matrix.size\n  var pos = FinderPattern.getPositions(version)\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0]\n    var col = pos[i][1]\n\n    for (var r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (var c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  var size = matrix.size\n\n  for (var r = 8; r < size - 8; r++) {\n    var value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  var pos = AlignmentPattern.getPositions(version)\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0]\n    var col = pos[i][1]\n\n    for (var r = -2; r <= 2; r++) {\n      for (var c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  var size = matrix.size\n  var bits = Version.getEncodedBits(version)\n  var row, col, mod\n\n  for (var i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  var size = matrix.size\n  var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  var i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\nfunction setupData (matrix, data) {\n  var size = matrix.size\n  var inc = -1\n  var row = size - 1\n  var bitIndex = 7\n  var byteIndex = 0\n\n  for (var col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (var c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          var dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  var buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  var totalCodewords = Utils.getSymbolTotalCodewords(version)\n  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (var i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  var totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  var dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  var blocksInGroup2 = totalCodewords % ecTotalBlocks\n  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  var rs = new ReedSolomonEncoder(ecCount)\n\n  var offset = 0\n  var dcData = new Array(ecTotalBlocks)\n  var ecData = new Array(ecTotalBlocks)\n  var maxDataSize = 0\n  var buffer = BufferUtil.from(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (var b = 0; b < ecTotalBlocks; b++) {\n    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  var data = BufferUtil.alloc(totalCodewords)\n  var index = 0\n  var i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  var segments\n\n  if (isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    var estimatedVersion = version\n\n    if (!estimatedVersion) {\n      var rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments,\n        errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  var bestVersion = Version.getBestVersionForData(segments,\n      errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  var dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  var moduleCount = Utils.getSymbolSize(version)\n  var modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  var errorCorrectionLevel = ECLevel.M\n  var version\n  var mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n"]},"metadata":{},"sourceType":"script"}