{"ast":null,"code":"import { extractExceptionKeysForMessage, isEvent, normalizeToSize } from '@sentry/utils';\nimport { computeStackTrace } from './tracekit';\nvar STACKTRACE_LIMIT = 50;\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\n\nexport function exceptionFromStacktrace(stacktrace) {\n  var frames = prepareFramesForEvent(stacktrace.stack);\n  var exception = {\n    type: stacktrace.name,\n    value: stacktrace.message\n  };\n\n  if (frames && frames.length) {\n    exception.stacktrace = {\n      frames: frames\n    };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n/**\n * @hidden\n */\n\nexport function eventFromPlainObject(exception, syntheticException, rejection) {\n  var event = {\n    exception: {\n      values: [{\n        type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',\n        value: \"Non-Error \" + (rejection ? 'promise rejection' : 'exception') + \" captured with keys: \" + extractExceptionKeysForMessage(exception)\n      }]\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception)\n    }\n  };\n\n  if (syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n\n  return event;\n}\n/**\n * @hidden\n */\n\nexport function eventFromStacktrace(stacktrace) {\n  var exception = exceptionFromStacktrace(stacktrace);\n  return {\n    exception: {\n      values: [exception]\n    }\n  };\n}\n/**\n * @hidden\n */\n\nexport function prepareFramesForEvent(stack) {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].func || '';\n  var lastFrameFunction = localStack[localStack.length - 1].func || ''; // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  } // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n\n\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  } // The frame where the crash happened, should be the last entry in the array\n\n\n  return localStack.slice(0, STACKTRACE_LIMIT).map(function (frame) {\n    return {\n      colno: frame.column === null ? undefined : frame.column,\n      filename: frame.url || localStack[0].url,\n      function: frame.func || '?',\n      in_app: true,\n      lineno: frame.line === null ? undefined : frame.line\n    };\n  }).reverse();\n}","map":{"version":3,"sources":["../src/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, Exception, StackFrame } from '@sentry/types';\nimport { extractExceptionKeysForMessage, isEvent, normalizeToSize } from '@sentry/utils';\n\nimport { computeStackTrace, StackFrame as TraceKitStackFrame, StackTrace as TraceKitStackTrace } from './tracekit';\n\nconst STACKTRACE_LIMIT = 50;\n\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromStacktrace(stacktrace: TraceKitStackTrace): Exception {\n  const frames = prepareFramesForEvent(stacktrace.stack);\n\n  const exception: Exception = {\n    type: stacktrace.name,\n    value: stacktrace.message,\n  };\n\n  if (frames && frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nexport function eventFromPlainObject(\n  exception: Record<string, unknown>,\n  syntheticException?: Error,\n  rejection?: boolean,\n): Event {\n  const event: Event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            rejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception),\n    },\n  };\n\n  if (syntheticException) {\n    const stacktrace = computeStackTrace(syntheticException);\n    const frames = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames,\n    };\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromStacktrace(stacktrace: TraceKitStackTrace): Event {\n  const exception = exceptionFromStacktrace(stacktrace);\n\n  return {\n    exception: {\n      values: [exception],\n    },\n  };\n}\n\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack: TraceKitStackFrame[]): StackFrame[] {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].func || '';\n  const lastFrameFunction = localStack[localStack.length - 1].func || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(\n      (frame: TraceKitStackFrame): StackFrame => ({\n        colno: frame.column === null ? undefined : frame.column,\n        filename: frame.url || localStack[0].url,\n        function: frame.func || '?',\n        in_app: true,\n        lineno: frame.line === null ? undefined : frame.line,\n      }),\n    )\n    .reverse();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}