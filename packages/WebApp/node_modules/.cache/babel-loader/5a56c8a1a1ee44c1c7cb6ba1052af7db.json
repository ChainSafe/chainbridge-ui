{"ast":null,"code":"// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\nconst util = require('./util');\n\nconst BN = require('bn.js'); // Convert from short to canonical names\n// FIXME: optimise or make this nicer?\n\n\nfunction elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n\n  return name;\n} // Parse N from type<N>\n\n\nfunction parseTypeN(type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n} // Parse N,M from type<N>x<M>\n\n\nfunction parseTypeNxM(type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n} // Parse N in type[<N>] where \"type\" can itself be an array type.\n\n\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n\n  return null;\n}\n\nfunction parseNumber(arg) {\n  var type = typeof arg;\n\n  if (type === 'string') {\n    if (util.isHexString(arg)) {\n      return new BN(util.stripHexPrefix(arg), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n} // Encodes a single item (can be dynamic array)\n// @returns: Buffer\n\n\nfunction encodeSingle(type, arg) {\n  var size, num, ret, i;\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg));\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0);\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'));\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?');\n    }\n\n    size = parseTypeArray(type);\n\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size);\n    }\n\n    ret = [];\n    type = type.slice(0, type.lastIndexOf('['));\n\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg);\n    }\n\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]));\n    }\n\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length);\n      ret.unshift(length);\n    }\n\n    return Buffer.concat(ret);\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg);\n    ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n\n    if (arg.length % 32 !== 0) {\n      ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);\n    }\n\n    return ret;\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n\n    return util.setLengthRight(arg, 32);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n\n    num = parseNumber(arg);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative');\n    }\n\n    return num.toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n\n    num = parseNumber(arg);\n\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type);\n    num = parseNumber(arg);\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative');\n    }\n\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type);\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type);\n} // Is a type dynamic?\n\n\nfunction isDynamic(type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';\n} // Is a type an array?\n\n\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n} // Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\n\n\nfunction rawEncode(types, values) {\n  var output = [];\n  var data = [];\n  var headLength = 32 * types.length;\n\n  for (var i in types) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    var cur = encodeSingle(type, value); // Use the head/tail method for storing dynamic data\n\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength));\n      data.push(cur);\n      headLength += cur.length;\n    } else {\n      output.push(cur);\n    }\n  }\n\n  return Buffer.concat(output.concat(data));\n}\n\nfunction solidityPack(types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values');\n  }\n\n  var size, num;\n  var ret = [];\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n\n    if (type === 'bytes') {\n      ret.push(value);\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'));\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'));\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20));\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type);\n\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size);\n      }\n\n      ret.push(util.setLengthRight(value, size));\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type);\n\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid uint<N> width: ' + size);\n      }\n\n      num = parseNumber(value);\n\n      if (num.bitLength() > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n      }\n\n      ret.push(num.toArrayLike(Buffer, 'be', size / 8));\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type);\n\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid int<N> width: ' + size);\n      }\n\n      num = parseNumber(value);\n\n      if (num.bitLength() > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n      }\n\n      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8));\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n\n  return Buffer.concat(ret);\n}\n\nfunction soliditySHA3(types, values) {\n  return util.keccak(solidityPack(types, values));\n}\n\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n};","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/walletlink/dist/vendor-js/eth-eip712-util/abi.js"],"names":["util","require","BN","elementaryName","name","startsWith","slice","parseTypeN","type","parseInt","exec","parseTypeNxM","tmp","parseTypeArray","match","parseNumber","arg","isHexString","stripHexPrefix","toArray","Error","encodeSingle","size","num","ret","i","Buffer","isArray","length","lastIndexOf","JSON","parse","push","unshift","concat","zeros","setLengthRight","bitLength","toArrayLike","toTwos","mul","pow","isDynamic","rawEncode","types","values","output","data","headLength","value","cur","solidityPack","setLength","soliditySHA3","keccak","module","exports"],"mappings":"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","sourcesContent":["// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\n\nconst util = require('./util')\nconst BN = require('bn.js')\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName (name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3)\n  } else if (name === 'int') {\n    return 'int256'\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4)\n  } else if (name === 'uint') {\n    return 'uint256'\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5)\n  } else if (name === 'fixed') {\n    return 'fixed128x128'\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6)\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128'\n  }\n  return name\n}\n\n// Parse N from type<N>\nfunction parseTypeN (type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10)\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM (type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type)\n  return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray (type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/)\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)\n  }\n  return null\n}\n\nfunction parseNumber (arg) {\n  var type = typeof arg\n  if (type === 'string') {\n    if (util.isHexString(arg)) {\n      return new BN(util.stripHexPrefix(arg), 16)\n    } else {\n      return new BN(arg, 10)\n    }\n  } else if (type === 'number') {\n    return new BN(arg)\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg\n  } else {\n    throw new Error('Argument is not a number')\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle (type, arg) {\n  var size, num, ret, i\n\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg))\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0)\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'))\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?')\n    }\n    size = parseTypeArray(type)\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size)\n    }\n    ret = []\n    type = type.slice(0, type.lastIndexOf('['))\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg)\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]))\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length)\n      ret.unshift(length)\n    }\n    return Buffer.concat(ret)\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg)\n\n    ret = Buffer.concat([ encodeSingle('uint256', arg.length), arg ])\n\n    if ((arg.length % 32) !== 0) {\n      ret = Buffer.concat([ ret, util.zeros(32 - (arg.length % 32)) ])\n    }\n\n    return ret\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type)\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size)\n    }\n\n    return util.setLengthRight(arg, 32)\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid uint<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    if (num < 0) {\n      throw new Error('Supplied uint is negative')\n    }\n\n    return num.toArrayLike(Buffer, 'be', 32)\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type)\n    if ((size % 8) || (size < 8) || (size > 256)) {\n      throw new Error('Invalid int<N> width: ' + size)\n    }\n\n    num = parseNumber(arg)\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\n    }\n\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32)\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type)\n\n    num = parseNumber(arg)\n\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative')\n    }\n\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type)\n\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))\n  }\n\n  throw new Error('Unsupported or invalid type: ' + type)\n}\n\n// Is a type dynamic?\nfunction isDynamic (type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')\n}\n\n// Is a type an array?\nfunction isArray (type) {\n  return type.lastIndexOf(']') === type.length - 1\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nfunction rawEncode (types, values) {\n  var output = []\n  var data = []\n\n  var headLength = 32 * types.length\n\n  for (var i in types) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n    var cur = encodeSingle(type, value)\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength))\n      data.push(cur)\n      headLength += cur.length\n    } else {\n      output.push(cur)\n    }\n  }\n\n  return Buffer.concat(output.concat(data))\n}\n\nfunction solidityPack (types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values')\n  }\n\n  var size, num\n  var ret = []\n\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i])\n    var value = values[i]\n\n    if (type === 'bytes') {\n      ret.push(value)\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'))\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'))\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20))\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type)\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size)\n      }\n\n      ret.push(util.setLengthRight(value, size))\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid uint<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      if (num.bitLength() > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())\n      }\n\n      ret.push(num.toArrayLike(Buffer, 'be', size / 8))\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type)\n      if ((size % 8) || (size < 8) || (size > 256)) {\n        throw new Error('Invalid int<N> width: ' + size)\n      }\n\n      num = parseNumber(value)\n      if (num.bitLength() > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())\n      }\n\n      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8))\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type)\n    }\n  }\n\n  return Buffer.concat(ret)\n}\n\nfunction soliditySHA3 (types, values) {\n  return util.keccak(solidityPack(types, values))\n}\n\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n}\n"]},"metadata":{},"sourceType":"script"}