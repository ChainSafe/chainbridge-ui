{"ast":null,"code":"var VersionCheck = require('./version-check');\n\nvar Regex = require('./regex');\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\n\n\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n};\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\n\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n};\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\n\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n};\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\n\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n};\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\n\nexports.MIXED = {\n  bit: -1\n};\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\n\nexports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version);\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n  return mode.ccBits[2];\n};\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\n\n\nexports.getBestModeForData = function getBestModeForData(dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n};\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\n\n\nexports.toString = function toString(mode) {\n  if (mode && mode.id) return mode.id;\n  throw new Error('Invalid mode');\n};\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\n\n\nexports.isValid = function isValid(mode) {\n  return mode && mode.bit && mode.ccBits;\n};\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\n\n\nfunction fromString(string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string');\n  }\n\n  var lcStr = string.toLowerCase();\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC;\n\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC;\n\n    case 'kanji':\n      return exports.KANJI;\n\n    case 'byte':\n      return exports.BYTE;\n\n    default:\n      throw new Error('Unknown mode: ' + string);\n  }\n}\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\n\n\nexports.from = function from(value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value;\n  }\n\n  try {\n    return fromString(value);\n  } catch (e) {\n    return defaultValue;\n  }\n};","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/qrcode/lib/core/mode.js"],"names":["VersionCheck","require","Regex","exports","NUMERIC","id","bit","ccBits","ALPHANUMERIC","BYTE","KANJI","MIXED","getCharCountIndicator","mode","version","Error","isValid","getBestModeForData","dataStr","testNumeric","testAlphanumeric","testKanji","toString","fromString","string","lcStr","toLowerCase","from","value","defaultValue","e"],"mappings":"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","sourcesContent":["var VersionCheck = require('./version-check')\nvar Regex = require('./regex')\n\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n}\n\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n}\n\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n}\n\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n}\n\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\nexports.MIXED = {\n  bit: -1\n}\n\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version)\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0]\n  else if (version < 27) return mode.ccBits[1]\n  return mode.ccBits[2]\n}\n\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\nexports.getBestModeForData = function getBestModeForData (dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\n  else return exports.BYTE\n}\n\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\nexports.toString = function toString (mode) {\n  if (mode && mode.id) return mode.id\n  throw new Error('Invalid mode')\n}\n\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\nexports.isValid = function isValid (mode) {\n  return mode && mode.bit && mode.ccBits\n}\n\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  var lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC\n    case 'kanji':\n      return exports.KANJI\n    case 'byte':\n      return exports.BYTE\n    default:\n      throw new Error('Unknown mode: ' + string)\n  }\n}\n\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n"]},"metadata":{},"sourceType":"script"}