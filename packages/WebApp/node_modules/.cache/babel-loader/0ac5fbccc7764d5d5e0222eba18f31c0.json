{"ast":null,"code":"var Mode = require('./mode');\n\nvar NumericData = require('./numeric-data');\n\nvar AlphanumericData = require('./alphanumeric-data');\n\nvar ByteData = require('./byte-data');\n\nvar KanjiData = require('./kanji-data');\n\nvar Regex = require('./regex');\n\nvar Utils = require('./utils');\n\nvar dijkstra = require('dijkstrajs');\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\n\n\nfunction getStringByteLength(str) {\n  return unescape(encodeURIComponent(str)).length;\n}\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\n\n\nfunction getSegments(regex, mode, str) {\n  var segments = [];\n  var result;\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    });\n  }\n\n  return segments;\n}\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\n\n\nfunction getSegmentsFromString(dataStr) {\n  var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);\n  var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);\n  var byteSegs;\n  var kanjiSegs;\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);\n    kanjiSegs = [];\n  }\n\n  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n  return segs.sort(function (s1, s2) {\n    return s1.index - s2.index;\n  }).map(function (obj) {\n    return {\n      data: obj.data,\n      mode: obj.mode,\n      length: obj.length\n    };\n  });\n}\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\n\n\nfunction getSegmentBitsLength(length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length);\n\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length);\n\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length);\n\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length);\n  }\n}\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\n\n\nfunction mergeSegments(segs) {\n  return segs.reduce(function (acc, curr) {\n    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data;\n      return acc;\n    }\n\n    acc.push(curr);\n    return acc;\n  }, []);\n}\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\n\n\nfunction buildNodes(segs) {\n  var nodes = [];\n\n  for (var i = 0; i < segs.length; i++) {\n    var seg = segs[i];\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.ALPHANUMERIC,\n          length: seg.length\n        }, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: seg.length\n        }]);\n        break;\n\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: seg.length\n        }]);\n        break;\n\n      case Mode.KANJI:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: getStringByteLength(seg.data)\n        }]);\n        break;\n\n      case Mode.BYTE:\n        nodes.push([{\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: getStringByteLength(seg.data)\n        }]);\n    }\n  }\n\n  return nodes;\n}\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\n\n\nfunction buildGraph(nodes, version) {\n  var table = {};\n  var graph = {\n    'start': {}\n  };\n  var prevNodeIds = ['start'];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeGroup = nodes[i];\n    var currentNodeIds = [];\n\n    for (var j = 0; j < nodeGroup.length; j++) {\n      var node = nodeGroup[j];\n      var key = '' + i + j;\n      currentNodeIds.push(key);\n      table[key] = {\n        node: node,\n        lastCount: 0\n      };\n      graph[key] = {};\n\n      for (var n = 0; n < prevNodeIds.length; n++) {\n        var prevNodeId = prevNodeIds[n];\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n          table[prevNodeId].lastCount += node.length;\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version); // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds;\n  }\n\n  for (n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]]['end'] = 0;\n  }\n\n  return {\n    map: graph,\n    table: table\n  };\n}\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\n\n\nfunction buildSingleSegment(data, modesHint) {\n  var mode;\n  var bestMode = Mode.getBestModeForData(data);\n  mode = Mode.from(modesHint, bestMode); // Make sure data can be encoded\n\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\\n Suggested mode is: ' + Mode.toString(bestMode));\n  } // Use Mode.BYTE if Kanji support is disabled\n\n\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE;\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data);\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data);\n\n    case Mode.KANJI:\n      return new KanjiData(data);\n\n    case Mode.BYTE:\n      return new ByteData(data);\n  }\n}\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\n\n\nexports.fromArray = function fromArray(array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null));\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode));\n    }\n\n    return acc;\n  }, []);\n};\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\n\n\nexports.fromString = function fromString(data, version) {\n  var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());\n  var nodes = buildNodes(segs);\n  var graph = buildGraph(nodes, version);\n  var path = dijkstra.find_path(graph.map, 'start', 'end');\n  var optimizedSegs = [];\n\n  for (var i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node);\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs));\n};\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\n\n\nexports.rawSplit = function rawSplit(data) {\n  return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));\n};","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/qrcode/lib/core/segments.js"],"names":["Mode","require","NumericData","AlphanumericData","ByteData","KanjiData","Regex","Utils","dijkstra","getStringByteLength","str","unescape","encodeURIComponent","length","getSegments","regex","mode","segments","result","exec","push","data","index","getSegmentsFromString","dataStr","numSegs","NUMERIC","alphaNumSegs","ALPHANUMERIC","byteSegs","kanjiSegs","isKanjiModeEnabled","BYTE","KANJI","BYTE_KANJI","segs","concat","sort","s1","s2","map","obj","getSegmentBitsLength","getBitsLength","mergeSegments","reduce","acc","curr","prevSeg","buildNodes","nodes","i","seg","buildGraph","version","table","graph","prevNodeIds","nodeGroup","currentNodeIds","j","node","key","lastCount","n","prevNodeId","getCharCountIndicator","buildSingleSegment","modesHint","bestMode","getBestModeForData","from","bit","Error","toString","exports","fromArray","array","fromString","path","find_path","optimizedSegs","rawSplit"],"mappings":"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","sourcesContent":["var Mode = require('./mode')\nvar NumericData = require('./numeric-data')\nvar AlphanumericData = require('./alphanumeric-data')\nvar ByteData = require('./byte-data')\nvar KanjiData = require('./kanji-data')\nvar Regex = require('./regex')\nvar Utils = require('./utils')\nvar dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  var segments = []\n  var result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  var byteSegs\n  var kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  var nodes = []\n  for (var i = 0; i < segs.length; i++) {\n    var seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  var table = {}\n  var graph = {'start': {}}\n  var prevNodeIds = ['start']\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeGroup = nodes[i]\n    var currentNodeIds = []\n\n    for (var j = 0; j < nodeGroup.length; j++) {\n      var node = nodeGroup[j]\n      var key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (var n = 0; n < prevNodeIds.length; n++) {\n        var prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]]['end'] = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  var mode\n  var bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  var nodes = buildNodes(segs)\n  var graph = buildGraph(nodes, version)\n  var path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  var optimizedSegs = []\n  for (var i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n"]},"metadata":{},"sourceType":"script"}