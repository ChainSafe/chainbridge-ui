{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst types_1 = require(\"../types\");\n\nconst ClientMessage_1 = require(\"./ClientMessage\");\n\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\n\nconst ServerMessage_1 = require(\"./ServerMessage\");\n\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\n\nclass WalletLinkConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param serverUrl Walletlinkd RPC URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, serverUrl, WebSocketClass = WebSocket) {\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = types_1.IntNumber(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws; // attempt to reconnect every 5 seconds when disconnected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    operators_1.skip(1), // if DISCONNECTED and not destroyed\n    operators_1.filter(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), // wait 5 seconds\n    operators_1.delay(5000), // check whether it's destroyed again\n    operators_1.filter(_ => !this.destroyed), // reconnect\n    operators_1.flatMap(_ => ws.connect()), operators_1.retry()).subscribe()); // perform authentication upon connection\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED and CONNECTING states\n    operators_1.skip(2), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe(operators_1.tap(_ => this.sendIsLinked()), operators_1.tap(_ => this.sendGetSessionConfig()), operators_1.map(_ => true)), // if not CONNECTED, emit false immediately\n    rxjs_1.of(false))), operators_1.distinctUntilChanged(), operators_1.catchError(_ => rxjs_1.of(false))).subscribe(connected => this.connectedSubject.next(connected))); // send heartbeat every n seconds while connected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    operators_1.skip(1), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, start the heartbeat timer\n    rxjs_1.timer(0, HEARTBEAT_INTERVAL)))).subscribe(i => // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat())); // handle server's heartbeat responses\n\n    this.subscriptions.add(ws.incomingData$.pipe(operators_1.filter(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat())); // handle link status updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe(operators_1.filter(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    })); // handle session config updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe(operators_1.filter(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n\n\n  connect() {\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletLinkConnection\n   */\n\n\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    this.destroyed = true;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n\n\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n\n\n  get onceConnected$() {\n    return this.connected$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n\n\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n\n\n  get onceLinked$() {\n    return this.linked$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n\n\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n\n\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe(operators_1.filter(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), operators_1.map(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n\n\n  setSessionMetadata(key, value) {\n    const message = ClientMessage_1.ClientMessageSetSessionConfig({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n\n\n  publishEvent(event, data, callWebhook = false) {\n    const message = ClientMessage_1.ClientMessagePublishEvent({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n\n      return res.eventId;\n    }));\n  }\n\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n\n  makeRequest(message, timeout = REQUEST_TIMEOUT) {\n    const reqId = message.id;\n\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return rxjs_1.throwError(err);\n    } // await server message with corresponding id\n\n\n    return this.ws.incomingJSONData$.pipe(operators_1.timeoutWith(timeout, rxjs_1.throwError(new Error(`request ${reqId} timed out`))), operators_1.filter(m => m.id === reqId), operators_1.take(1));\n  }\n\n  authenticate() {\n    const msg = ClientMessage_1.ClientMessageHostSession({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe(operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n\n  sendIsLinked() {\n    const msg = ClientMessage_1.ClientMessageIsLinked({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n  sendGetSessionConfig() {\n    const msg = ClientMessage_1.ClientMessageGetSessionConfig({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n}\n\nexports.WalletLinkConnection = WalletLinkConnection;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/walletlink/dist/connection/WalletLinkConnection.js"],"names":["Object","defineProperty","exports","value","rxjs_1","require","operators_1","types_1","ClientMessage_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","WalletLinkConnection","constructor","sessionId","sessionKey","serverUrl","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","tap","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","linked","onlineGuests","webhookId","webhookUrl","metadata","Error","destroy","unsubscribe","disconnect","connected$","asObservable","onceConnected$","v","take","linked$","onceLinked$","sessionConfig$","incomingEvent$","sme","eventId","event","data","setSessionMetadata","key","message","ClientMessageSetSessionConfig","id","makeRequest","res","isServerMessageFail","error","publishEvent","callWebhook","ClientMessagePublishEvent","sendData","JSON","stringify","Date","now","_a","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\nclass WalletLinkConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param serverUrl Walletlinkd RPC URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, serverUrl, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = types_1.IntNumber(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        operators_1.skip(1), \n        // if DISCONNECTED and not destroyed\n        operators_1.filter(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        operators_1.delay(5000), \n        // check whether it's destroyed again\n        operators_1.filter(_ => !this.destroyed), \n        // reconnect\n        operators_1.flatMap(_ => ws.connect()), operators_1.retry())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        operators_1.skip(2), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe(operators_1.tap(_ => this.sendIsLinked()), operators_1.tap(_ => this.sendGetSessionConfig()), operators_1.map(_ => true)), \n        // if not CONNECTED, emit false immediately\n        rxjs_1.of(false))), operators_1.distinctUntilChanged(), operators_1.catchError(_ => rxjs_1.of(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        operators_1.skip(1), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        rxjs_1.timer(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe(operators_1.filter(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe(operators_1.filter(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            const msg = m;\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe(operators_1.filter(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            const msg = m;\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletLinkConnection\n     */\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        this.destroyed = true;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe(operators_1.filter(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), operators_1.map(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = ClientMessage_1.ClientMessageSetSessionConfig({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value }\n        });\n        return this.onceConnected$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n            if (ServerMessage_1.isServerMessageFail(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = ClientMessage_1.ClientMessagePublishEvent({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook\n        });\n        return this.onceLinked$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n            if (ServerMessage_1.isServerMessageFail(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return rxjs_1.throwError(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe(operators_1.timeoutWith(timeout, rxjs_1.throwError(new Error(`request ${reqId} timed out`))), operators_1.filter(m => m.id === reqId), operators_1.take(1));\n    }\n    authenticate() {\n        const msg = ClientMessage_1.ClientMessageHostSession({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey\n        });\n        return this.makeRequest(msg).pipe(operators_1.map(res => {\n            if (ServerMessage_1.isServerMessageFail(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = ClientMessage_1.ClientMessageIsLinked({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = ClientMessage_1.ClientMessageGetSessionConfig({\n            id: types_1.IntNumber(this.nextReqId++),\n            sessionId: this.sessionId\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletLinkConnection = WalletLinkConnection;\n"]},"metadata":{},"sourceType":"script"}