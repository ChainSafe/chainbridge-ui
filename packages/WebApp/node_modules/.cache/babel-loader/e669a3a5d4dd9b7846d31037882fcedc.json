{"ast":null,"code":"import { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, SyncPromise } from '@sentry/utils';\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n/**\n * Builds and Event from a Exception\n * @hidden\n */\n\nexport function eventFromException(options, exception, hint) {\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic'\n  });\n  event.level = Severity.Error;\n\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n\n  return SyncPromise.resolve(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\n\nexport function eventFromMessage(options, message, level, hint) {\n  if (level === void 0) {\n    level = Severity.Info;\n  }\n\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  event.level = level;\n\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n\n  return SyncPromise.resolve(event);\n}\n/**\n * @hidden\n */\n\nexport function eventFromUnknownInput(exception, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var event;\n\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception; // eslint-disable-next-line no-param-reassign\n\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n\n  if (isDOMError(exception) || isDOMException(exception)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    var domException = exception;\n    var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n    return event;\n  }\n\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    var objectException = exception;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  } // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n\n\n  event = eventFromString(exception, syntheticException, options);\n  addExceptionTypeValue(event, \"\" + exception, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\n/**\n * @hidden\n */\n\nexport function eventFromString(input, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var event = {\n    message: input\n  };\n\n  if (options.attachStacktrace && syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n\n  return event;\n}","map":{"version":3,"sources":["../src/eventbuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventHint, Options, Severity } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  isDOMError,\n  isDOMException,\n  isError,\n  isErrorEvent,\n  isEvent,\n  isPlainObject,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options: Options, exception: unknown, hint?: EventHint): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace,\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic',\n  });\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  options: Options,\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace,\n  });\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(\n  exception: unknown,\n  syntheticException?: Error,\n  options: {\n    rejection?: boolean;\n    attachStacktrace?: boolean;\n  } = {},\n): Event {\n  let event: Event;\n\n  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception as ErrorEvent;\n    // eslint-disable-next-line no-param-reassign\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception as Error));\n    return event;\n  }\n  if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    const domException = exception as DOMException;\n    const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    const message = domException.message ? `${name}: ${domException.message}` : name;\n\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n    return event;\n  }\n  if (isError(exception as Error)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception as Error));\n    return event;\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    const objectException = exception as Record<string, unknown>;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception as string, syntheticException, options);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromString(\n  input: string,\n  syntheticException?: Error,\n  options: {\n    attachStacktrace?: boolean;\n  } = {},\n): Event {\n  const event: Event = {\n    message: input,\n  };\n\n  if (options.attachStacktrace && syntheticException) {\n    const stacktrace = computeStackTrace(syntheticException);\n    const frames = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames,\n    };\n  }\n\n  return event;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}