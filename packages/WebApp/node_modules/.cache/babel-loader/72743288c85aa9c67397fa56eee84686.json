{"ast":null,"code":"import SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: transaction,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nvar version = \"2.1.5\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    retryMs,\n    limitRules,\n    blockedMsg\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit')) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      eventCode,\n      contractCall\n    } : { ...transaction,\n      eventCode\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === transaction.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  });\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_NAME = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_NAME,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/bnc-sdk/dist/esm/index.js"],"names":["SturdyWebSocket","CryptoEs","networks","bitcoin","ethereum","DEFAULT_RATE_LIMIT_RULES","points","duration","QUEUE_LIMIT","createEmitter","listeners","on","eventCode","listener","Error","emit","state","all","networkName","blockchain","id","serverEcho","last","arr","reverse","isAddress","addressOrHash","length","isTxid","wait","time","Promise","resolve","setTimeout","transaction","hash","_destroyed","startTime","Date","now","emitter","_watchedTransactions","push","_system","status","newState","_sendMessage","categoryCode","transactionObj","details","emitState","emitterResult","_transactionHandlers","forEach","handler","bind","account","address","toLowerCase","existingAddressWatcher","_watchedAccounts","find","ac","emitters","event","eventObj","unsubscribe","txid","normalizedAddress","filter","tx","version","sendMessage","msg","_queuedMessages","createEventLog","_processingQueue","_processQueue","processQueue","_connected","waitForConnectionOpen","_waitToRetry","shift","delay","_limitRules","_socket","send","handleMessage","reason","connectionId","retryMs","limitRules","blockedMsg","JSON","parse","data","window","localStorage","setItem","_storageKey","_connectionId","includes","unshift","_onerror","message","contractCall","map","originalHash","watchedAddress","accountObj","stringify","timeStamp","dappId","_dappId","system","network","_networkId","interval","setInterval","clearInterval","validateType","options","name","value","type","optional","customValidation","Array","isArray","validateOptions","networkId","transactionHandlers","apiUrl","ws","onopen","ondown","onreopen","onerror","onclose","otherParams","invalidParams","validSystem","params","validParams","functionName","invalid","Object","keys","join","DEFAULT_NAME","DEFAULT_SYSTEM","Blocknative","constructor","socket","wsConstructor","onOpen","onDown","onReopen","onmessage","error","_pingTimeout","storageKey","SHA1","toString","storedConnectionId","getItem","undefined","_heartbeat","clearTimeout","terminate","destroy","close","closeEvent"],"mappings":"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","sourcesContent":["import SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: transaction,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nvar version = \"2.1.5\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    retryMs,\n    limitRules,\n    blockedMsg\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit')) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      eventCode,\n      contractCall\n    } : { ...transaction,\n      eventCode\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === transaction.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const emitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  });\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_NAME = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_NAME,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;\n"]},"metadata":{},"sourceType":"module"}