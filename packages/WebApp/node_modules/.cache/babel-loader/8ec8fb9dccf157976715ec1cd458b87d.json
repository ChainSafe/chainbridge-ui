{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (tasks, callback) {\n  callback = (0, _once2.default)(callback || _noop2.default);\n  if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n  if (!tasks.length) return callback();\n  var taskIndex = 0;\n\n  function nextTask(args) {\n    var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n    args.push((0, _onlyOnce2.default)(next));\n    task.apply(null, args);\n  }\n\n  function next(err\n  /*, ...args*/\n  ) {\n    if (err || taskIndex === tasks.length) {\n      return callback.apply(null, arguments);\n    }\n\n    nextTask((0, _slice2.default)(arguments, 1));\n  }\n\n  nextTask([]);\n};\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _slice = require('./internal/slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = exports['default'];\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/async/waterfall.js"],"names":["Object","defineProperty","exports","value","default","tasks","callback","_once2","_noop2","_isArray2","Error","length","taskIndex","nextTask","args","task","_wrapAsync2","push","_onlyOnce2","next","apply","err","arguments","_slice2","_isArray","require","_interopRequireDefault","_noop","_once","_slice","_onlyOnce","_wrapAsync","obj","__esModule","module"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AACzCC,EAAAA,KAAK,EAAE;AADkC,CAA7C;;AAIAD,OAAO,CAACE,OAAR,GAAkB,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AACzCA,EAAAA,QAAQ,GAAG,CAAC,GAAGC,MAAM,CAACH,OAAX,EAAoBE,QAAQ,IAAIE,MAAM,CAACJ,OAAvC,CAAX;AACA,MAAI,CAAC,CAAC,GAAGK,SAAS,CAACL,OAAd,EAAuBC,KAAvB,CAAL,EAAoC,OAAOC,QAAQ,CAAC,IAAII,KAAJ,CAAU,2DAAV,CAAD,CAAf;AACpC,MAAI,CAACL,KAAK,CAACM,MAAX,EAAmB,OAAOL,QAAQ,EAAf;AACnB,MAAIM,SAAS,GAAG,CAAhB;;AAEA,WAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACpB,QAAIC,IAAI,GAAG,CAAC,GAAGC,WAAW,CAACZ,OAAhB,EAAyBC,KAAK,CAACO,SAAS,EAAV,CAA9B,CAAX;AACAE,IAAAA,IAAI,CAACG,IAAL,CAAU,CAAC,GAAGC,UAAU,CAACd,OAAf,EAAwBe,IAAxB,CAAV;AACAJ,IAAAA,IAAI,CAACK,KAAL,CAAW,IAAX,EAAiBN,IAAjB;AACH;;AAED,WAASK,IAAT,CAAcE;AAAI;AAAlB,IAAiC;AAC7B,QAAIA,GAAG,IAAIT,SAAS,KAAKP,KAAK,CAACM,MAA/B,EAAuC;AACnC,aAAOL,QAAQ,CAACc,KAAT,CAAe,IAAf,EAAqBE,SAArB,CAAP;AACH;;AACDT,IAAAA,QAAQ,CAAC,CAAC,GAAGU,OAAO,CAACnB,OAAZ,EAAqBkB,SAArB,EAAgC,CAAhC,CAAD,CAAR;AACH;;AAEDT,EAAAA,QAAQ,CAAC,EAAD,CAAR;AACH,CApBD;;AAsBA,IAAIW,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;;AAEA,IAAIhB,SAAS,GAAGiB,sBAAsB,CAACF,QAAD,CAAtC;;AAEA,IAAIG,KAAK,GAAGF,OAAO,CAAC,aAAD,CAAnB;;AAEA,IAAIjB,MAAM,GAAGkB,sBAAsB,CAACC,KAAD,CAAnC;;AAEA,IAAIC,KAAK,GAAGH,OAAO,CAAC,iBAAD,CAAnB;;AAEA,IAAIlB,MAAM,GAAGmB,sBAAsB,CAACE,KAAD,CAAnC;;AAEA,IAAIC,MAAM,GAAGJ,OAAO,CAAC,kBAAD,CAApB;;AAEA,IAAIF,OAAO,GAAGG,sBAAsB,CAACG,MAAD,CAApC;;AAEA,IAAIC,SAAS,GAAGL,OAAO,CAAC,qBAAD,CAAvB;;AAEA,IAAIP,UAAU,GAAGQ,sBAAsB,CAACI,SAAD,CAAvC;;AAEA,IAAIC,UAAU,GAAGN,OAAO,CAAC,sBAAD,CAAxB;;AAEA,IAAIT,WAAW,GAAGU,sBAAsB,CAACK,UAAD,CAAxC;;AAEA,SAASL,sBAAT,CAAgCM,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAE5B,IAAAA,OAAO,EAAE4B;AAAX,GAArC;AAAwD;;AAE/FE,MAAM,CAAChC,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB;AAEA","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nexports.default = function (tasks, callback) {\n    callback = (0, _once2.default)(callback || _noop2.default);\n    if (!(0, _isArray2.default)(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);\n        args.push((0, _onlyOnce2.default)(next));\n        task.apply(null, args);\n    }\n\n    function next(err /*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask((0, _slice2.default)(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _once = require('./internal/once');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _slice = require('./internal/slice');\n\nvar _slice2 = _interopRequireDefault(_slice);\n\nvar _onlyOnce = require('./internal/onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports['default'];\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */"]},"metadata":{},"sourceType":"script"}