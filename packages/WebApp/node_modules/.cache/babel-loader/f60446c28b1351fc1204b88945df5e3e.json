{"ast":null,"code":"/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\nconst waterfall = require('async/waterfall');\n\nconst parallel = require('async/parallel');\n\nconst inherits = require('util').inherits;\n\nconst ethUtil = require('ethereumjs-util');\n\nconst sigUtil = require('eth-sig-util');\n\nconst extend = require('xtend');\n\nconst Semaphore = require('semaphore');\n\nconst Subprovider = require('./subprovider.js');\n\nconst estimateGas = require('../util/estimate-gas.js');\n\nconst hexRegex = /^[0-9A-Fa-f]+$/g;\nmodule.exports = HookedWalletSubprovider; // handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   personal_sign\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\ninherits(HookedWalletSubprovider, Subprovider);\n\nfunction HookedWalletSubprovider(opts) {\n  const self = this; // control flow\n\n  self.nonceLock = Semaphore(1); // data lookup\n\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts; // high level override\n\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction;\n  if (opts.processSignTransaction) self.processSignTransaction = opts.processSignTransaction;\n  if (opts.processMessage) self.processMessage = opts.processMessage;\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage;\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage; // approval hooks\n\n  self.approveTransaction = opts.approveTransaction || self.autoApprove;\n  self.approveMessage = opts.approveMessage || self.autoApprove;\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove;\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove; // actually perform the signature\n\n  self.signTransaction = opts.signTransaction || mustProvideInConstructor('signTransaction');\n  self.signMessage = opts.signMessage || mustProvideInConstructor('signMessage');\n  self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor('signPersonalMessage');\n  self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor('signTypedMessage');\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature; // publish to network\n\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction; // gas options\n\n  self.estimateGas = opts.estimateGas || self.estimateGas;\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice;\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n  self._parityRequests = {};\n  self._parityRequestCount = 0; // switch statement is not block scoped\n  // sp we cant repeat var declarations\n\n  let txParams, msgParams, extraParams;\n  let message, address;\n\n  switch (payload.method) {\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        let result = accounts[0] || null;\n        end(null, result);\n      });\n      return;\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        end(null, accounts);\n      });\n      return;\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processSignTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0];\n      message = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n\n      extraParams = payload.params[2] || {};\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      waterfall([cb => self.validateMessage(msgParams, cb), cb => self.processMessage(msgParams, cb)], end);\n      return;\n\n    case 'personal_sign':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validatePersonalMessage(msgParams, cb), cb => self.processPersonalMessage(msgParams, cb)], end);\n      }();\n\n    case 'personal_ecRecover':\n      return function () {\n        message = payload.params[0];\n        let signature = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message\n        });\n        self.recoverPersonalSignature(msgParams, end);\n      }();\n\n    case 'eth_signTypedData':\n      // process normally\n      message = payload.params[0];\n      address = payload.params[1];\n      extraParams = payload.params[2] || {};\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      waterfall([cb => self.validateTypedMessage(msgParams, cb), cb => self.processTypedMessage(msgParams, cb)], end);\n      return;\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0];\n      self.parityPostTransaction(txParams, end);\n      return;\n\n    case 'parity_postSign':\n      address = payload.params[0];\n      message = payload.params[1];\n      self.parityPostSign(address, message, end);\n      return;\n\n    case 'parity_checkRequest':\n      return function () {\n        const requestId = payload.params[0];\n        self.parityCheckRequest(requestId, end);\n      }();\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        const account = accounts[0] || null;\n        end(null, account);\n      });\n      return;\n\n    default:\n      next();\n      return;\n  }\n}; //\n// data lookup\n//\n\n\nHookedWalletSubprovider.prototype.getAccounts = function (cb) {\n  cb(null, []);\n}; //\n// \"process\" high level flow\n//\n\n\nHookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeAndSubmitTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processSignTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approvePersonalMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signPersonalMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processTypedMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTypedMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signTypedMessage(msgParams, cb)], cb);\n}; //\n// approval\n//\n\n\nHookedWalletSubprovider.prototype.autoApprove = function (txParams, cb) {\n  cb(null, true);\n};\n\nHookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {\n  cb(didApprove ? null : new Error('User denied ' + type + ' signature.'));\n}; //\n// parity\n//\n\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function (txParams, cb) {\n  const self = this; // get next id\n\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n\n    const txHash = res.result;\n    self._parityRequests[reqId] = txHash;\n  });\n  cb(null, reqId);\n};\n\nHookedWalletSubprovider.prototype.parityPostSign = function (address, message, cb) {\n  const self = this; // get next id\n\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n\n    const result = res.result;\n    self._parityRequests[reqId] = result;\n  });\n  cb(null, reqId);\n};\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function (reqId, cb) {\n  const self = this;\n  const result = self._parityRequests[reqId] || null; // tx not handled yet\n\n  if (!result) return cb(null, null); // tx was rejected (or other error)\n\n  if (result.error) return cb(result.error); // tx sent\n\n  cb(null, result);\n}; //\n// signature and recovery\n//\n\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function (msgParams, cb) {\n  let senderHex;\n\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams);\n  } catch (err) {\n    return cb(err);\n  }\n\n  cb(null, senderHex);\n}; //\n// validation\n//\n\n\nHookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`));\n  self.validateSender(txParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function (msgParams, cb) {\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`));\n  this.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (!senderAddress) return cb(null, false);\n  self.getAccounts(function (err, accounts) {\n    if (err) return cb(err);\n    const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;\n    cb(null, senderIsValid);\n  });\n}; //\n// tx helpers\n//\n\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function (err, txHash) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, txHash);\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.finalizeTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self)], function (err, signedTx) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, {\n        raw: signedTx,\n        tx: txParams\n      });\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx]\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.estimateGas = function (txParams, cb) {\n  const self = this;\n  estimateGas(self.engine, txParams, cb);\n};\n\nHookedWalletSubprovider.prototype.getGasPrice = function (cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_gasPrice',\n    params: []\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {\n  const self = this;\n  const address = txParams.from; // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {};\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self);\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending']\n    });\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams));\n  }\n\n  parallel(tasks, function (err, taskResults) {\n    if (err) return cb(err);\n    const result = {};\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice;\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result;\n    if (taskResults.gas) result.gas = taskResults.gas;\n    cb(null, extend(txParams, result));\n  });\n}; // util\n// we use this to clean any custom params from the txParams\n\n\nfunction cloneTxParams(txParams) {\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce\n  };\n}\n\nfunction toLowerCase(string) {\n  return string.toLowerCase();\n}\n\nfunction resemblesAddress(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValid = ethUtil.isValidAddress(fixed);\n  return isValid;\n} // Returns true if resembles hex data\n// but definitely not a valid address.\n\n\nfunction resemblesData(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValidAddress = ethUtil.isValidAddress(fixed);\n  return !isValidAddress && isValidHex(string);\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string';\n  if (!isString) return false;\n  const isHexPrefixed = data.slice(0, 2) === '0x';\n  if (!isHexPrefixed) return false;\n  const nonPrefixed = data.slice(2);\n  const isValid = nonPrefixed.match(hexRegex);\n  return isValid;\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function (params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'));\n  };\n}","map":{"version":3,"sources":["/home/ryann/Documents/Repos/ChainSafe/chainbridge-ui/node_modules/authereum/node_modules/web3-provider-engine/subproviders/hooked-wallet.js"],"names":["waterfall","require","parallel","inherits","ethUtil","sigUtil","extend","Semaphore","Subprovider","estimateGas","hexRegex","module","exports","HookedWalletSubprovider","opts","self","nonceLock","getAccounts","processTransaction","processSignTransaction","processMessage","processPersonalMessage","processTypedMessage","approveTransaction","autoApprove","approveMessage","approvePersonalMessage","approveTypedMessage","signTransaction","mustProvideInConstructor","signMessage","signPersonalMessage","signTypedMessage","recoverPersonalSignature","publishTransaction","getGasPrice","prototype","handleRequest","payload","next","end","_parityRequests","_parityRequestCount","txParams","msgParams","extraParams","message","address","method","err","accounts","result","params","cb","validateTransaction","from","data","validateMessage","first","second","resemblesData","resemblesAddress","warning","console","warn","validatePersonalMessage","signature","sig","validateTypedMessage","parityPostTransaction","parityPostSign","requestId","parityCheckRequest","account","didApprove","checkApproval","finalizeAndSubmitTx","finalizeTx","type","Error","count","reqId","toString","emitPayload","error","res","txHash","senderHex","undefined","validateSender","senderIsValid","isValidHex","senderAddress","map","toLowerCase","indexOf","take","fillInTxExtras","bind","leave","signedTx","raw","tx","rawTx","engine","tasks","gasPrice","nonce","gas","cloneTxParams","taskResults","to","value","string","fixed","addHexPrefix","isValid","isValidAddress","isString","isHexPrefixed","slice","nonPrefixed","match","methodName"],"mappings":"AAAA;;;;;;;AAQA,MAAMA,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,MAAD,CAAP,CAAgBE,QAAjC;;AACA,MAAMC,OAAO,GAAGH,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,OAAD,CAAtB;;AACA,MAAMM,SAAS,GAAGN,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMO,WAAW,GAAGP,OAAO,CAAC,kBAAD,CAA3B;;AACA,MAAMQ,WAAW,GAAGR,OAAO,CAAC,yBAAD,CAA3B;;AACA,MAAMS,QAAQ,GAAG,iBAAjB;AAEAC,MAAM,CAACC,OAAP,GAAiBC,uBAAjB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGAV,QAAQ,CAACU,uBAAD,EAA0BL,WAA1B,CAAR;;AAEA,SAASK,uBAAT,CAAiCC,IAAjC,EAAsC;AACpC,QAAMC,IAAI,GAAG,IAAb,CADoC,CAEpC;;AACAA,EAAAA,IAAI,CAACC,SAAL,GAAiBT,SAAS,CAAC,CAAD,CAA1B,CAHoC,CAKpC;;AACA,MAAIO,IAAI,CAACG,WAAT,EAAsBF,IAAI,CAACE,WAAL,GAAmBH,IAAI,CAACG,WAAxB,CANc,CAOpC;;AACA,MAAIH,IAAI,CAACI,kBAAT,EAA6BH,IAAI,CAACG,kBAAL,GAA0BJ,IAAI,CAACI,kBAA/B;AAC7B,MAAIJ,IAAI,CAACK,sBAAT,EAAiCJ,IAAI,CAACI,sBAAL,GAA8BL,IAAI,CAACK,sBAAnC;AACjC,MAAIL,IAAI,CAACM,cAAT,EAAyBL,IAAI,CAACK,cAAL,GAAsBN,IAAI,CAACM,cAA3B;AACzB,MAAIN,IAAI,CAACO,sBAAT,EAAiCN,IAAI,CAACM,sBAAL,GAA8BP,IAAI,CAACO,sBAAnC;AACjC,MAAIP,IAAI,CAACQ,mBAAT,EAA8BP,IAAI,CAACO,mBAAL,GAA2BR,IAAI,CAACQ,mBAAhC,CAZM,CAapC;;AACAP,EAAAA,IAAI,CAACQ,kBAAL,GAA0BT,IAAI,CAACS,kBAAL,IAA2BR,IAAI,CAACS,WAA1D;AACAT,EAAAA,IAAI,CAACU,cAAL,GAAsBX,IAAI,CAACW,cAAL,IAAuBV,IAAI,CAACS,WAAlD;AACAT,EAAAA,IAAI,CAACW,sBAAL,GAA8BZ,IAAI,CAACY,sBAAL,IAA+BX,IAAI,CAACS,WAAlE;AACAT,EAAAA,IAAI,CAACY,mBAAL,GAA2Bb,IAAI,CAACa,mBAAL,IAA4BZ,IAAI,CAACS,WAA5D,CAjBoC,CAkBpC;;AACAT,EAAAA,IAAI,CAACa,eAAL,GAAuBd,IAAI,CAACc,eAAL,IAAyBC,wBAAwB,CAAC,iBAAD,CAAxE;AACAd,EAAAA,IAAI,CAACe,WAAL,GAAmBhB,IAAI,CAACgB,WAAL,IAAqBD,wBAAwB,CAAC,aAAD,CAAhE;AACAd,EAAAA,IAAI,CAACgB,mBAAL,GAA2BjB,IAAI,CAACiB,mBAAL,IAA6BF,wBAAwB,CAAC,qBAAD,CAAhF;AACAd,EAAAA,IAAI,CAACiB,gBAAL,GAAwBlB,IAAI,CAACkB,gBAAL,IAA0BH,wBAAwB,CAAC,kBAAD,CAA1E;AACA,MAAIf,IAAI,CAACmB,wBAAT,EAAmClB,IAAI,CAACkB,wBAAL,GAAgCnB,IAAI,CAACmB,wBAArC,CAvBC,CAwBpC;;AACA,MAAInB,IAAI,CAACoB,kBAAT,EAA6BnB,IAAI,CAACmB,kBAAL,GAA0BpB,IAAI,CAACoB,kBAA/B,CAzBO,CA0BpC;;AACAnB,EAAAA,IAAI,CAACN,WAAL,GAAmBK,IAAI,CAACL,WAAL,IAAoBM,IAAI,CAACN,WAA5C;AACAM,EAAAA,IAAI,CAACoB,WAAL,GAAmBrB,IAAI,CAACqB,WAAL,IAAoBpB,IAAI,CAACoB,WAA5C;AACD;;AAEDtB,uBAAuB,CAACuB,SAAxB,CAAkCC,aAAlC,GAAkD,UAASC,OAAT,EAAkBC,IAAlB,EAAwBC,GAAxB,EAA4B;AAC5E,QAAMzB,IAAI,GAAG,IAAb;AACAA,EAAAA,IAAI,CAAC0B,eAAL,GAAuB,EAAvB;AACA1B,EAAAA,IAAI,CAAC2B,mBAAL,GAA2B,CAA3B,CAH4E,CAK5E;AACA;;AACA,MAAIC,QAAJ,EAAcC,SAAd,EAAyBC,WAAzB;AACA,MAAIC,OAAJ,EAAaC,OAAb;;AAEA,UAAOT,OAAO,CAACU,MAAf;AAEE,SAAK,cAAL;AACE;AACAjC,MAAAA,IAAI,CAACE,WAAL,CAAiB,UAASgC,GAAT,EAAcC,QAAd,EAAuB;AACtC,YAAID,GAAJ,EAAS,OAAOT,GAAG,CAACS,GAAD,CAAV;AACT,YAAIE,MAAM,GAAGD,QAAQ,CAAC,CAAD,CAAR,IAAe,IAA5B;AACAV,QAAAA,GAAG,CAAC,IAAD,EAAOW,MAAP,CAAH;AACD,OAJD;AAKA;;AAEF,SAAK,cAAL;AACE;AACApC,MAAAA,IAAI,CAACE,WAAL,CAAiB,UAASgC,GAAT,EAAcC,QAAd,EAAuB;AACtC,YAAID,GAAJ,EAAS,OAAOT,GAAG,CAACS,GAAD,CAAV;AACTT,QAAAA,GAAG,CAAC,IAAD,EAAOU,QAAP,CAAH;AACD,OAHD;AAIA;;AAEF,SAAK,qBAAL;AACEP,MAAAA,QAAQ,GAAGL,OAAO,CAACc,MAAR,CAAe,CAAf,CAAX;AACApD,MAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACuC,mBAAL,CAAyBX,QAAzB,EAAmCU,EAAnC,CADA,EAEPA,EAAD,IAAQtC,IAAI,CAACG,kBAAL,CAAwByB,QAAxB,EAAkCU,EAAlC,CAFA,CAAD,EAGNb,GAHM,CAAT;AAIA;;AAEF,SAAK,qBAAL;AACEG,MAAAA,QAAQ,GAAGL,OAAO,CAACc,MAAR,CAAe,CAAf,CAAX;AACApD,MAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACuC,mBAAL,CAAyBX,QAAzB,EAAmCU,EAAnC,CADA,EAEPA,EAAD,IAAQtC,IAAI,CAACI,sBAAL,CAA4BwB,QAA5B,EAAsCU,EAAtC,CAFA,CAAD,EAGNb,GAHM,CAAT;AAIA;;AAEF,SAAK,UAAL;AACE;AACAO,MAAAA,OAAO,GAAGT,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACAN,MAAAA,OAAO,GAAGR,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV,CAHF,CAIE;AACA;;AACAP,MAAAA,WAAW,GAAGP,OAAO,CAACc,MAAR,CAAe,CAAf,KAAqB,EAAnC;AACAR,MAAAA,SAAS,GAAGtC,MAAM,CAACuC,WAAD,EAAc;AAC9BU,QAAAA,IAAI,EAAER,OADwB;AAE9BS,QAAAA,IAAI,EAAEV;AAFwB,OAAd,CAAlB;AAIA9C,MAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAAC0C,eAAL,CAAqBb,SAArB,EAAgCS,EAAhC,CADA,EAEPA,EAAD,IAAQtC,IAAI,CAACK,cAAL,CAAoBwB,SAApB,EAA+BS,EAA/B,CAFA,CAAD,EAGNb,GAHM,CAAT;AAIA;;AAEF,SAAK,eAAL;AACE,aAAQ,YAAU;AAChB;AACA,cAAMkB,KAAK,GAAGpB,OAAO,CAACc,MAAR,CAAe,CAAf,CAAd;AACA,cAAMO,MAAM,GAAGrB,OAAO,CAACc,MAAR,CAAe,CAAf,CAAf,CAHgB,CAKhB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAIQ,aAAa,CAACD,MAAD,CAAb,IAAyBE,gBAAgB,CAACH,KAAD,CAA7C,EAAsD;AACpD,cAAII,OAAO,GAAI,sDAAf;AACAA,UAAAA,OAAO,IAAK,+DAAZ;AACAA,UAAAA,OAAO,IAAK,wCAAZ;AACAA,UAAAA,OAAO,IAAK,mEAAZ;AACAC,UAAAA,OAAO,CAACC,IAAR,CAAaF,OAAb;AAEAf,UAAAA,OAAO,GAAGT,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACAN,UAAAA,OAAO,GAAGR,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACD,SATD,MASO;AACLN,UAAAA,OAAO,GAAGR,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACAL,UAAAA,OAAO,GAAGT,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACD,SAxBe,CA0BhB;AACA;;;AACAP,QAAAA,WAAW,GAAGP,OAAO,CAACc,MAAR,CAAe,CAAf,KAAqB,EAAnC;AACAR,QAAAA,SAAS,GAAGtC,MAAM,CAACuC,WAAD,EAAc;AAC9BU,UAAAA,IAAI,EAAER,OADwB;AAE9BS,UAAAA,IAAI,EAAEV;AAFwB,SAAd,CAAlB;AAIA9C,QAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACkD,uBAAL,CAA6BrB,SAA7B,EAAwCS,EAAxC,CADA,EAEPA,EAAD,IAAQtC,IAAI,CAACM,sBAAL,CAA4BuB,SAA5B,EAAuCS,EAAvC,CAFA,CAAD,EAGNb,GAHM,CAAT;AAID,OArCM,EAAP;;AAuCF,SAAK,oBAAL;AACE,aAAQ,YAAU;AAChBM,QAAAA,OAAO,GAAGR,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACA,YAAIc,SAAS,GAAG5B,OAAO,CAACc,MAAR,CAAe,CAAf,CAAhB,CAFgB,CAGhB;AACA;;AACAP,QAAAA,WAAW,GAAGP,OAAO,CAACc,MAAR,CAAe,CAAf,KAAqB,EAAnC;AACAR,QAAAA,SAAS,GAAGtC,MAAM,CAACuC,WAAD,EAAc;AAC9BsB,UAAAA,GAAG,EAAED,SADyB;AAE9BV,UAAAA,IAAI,EAAEV;AAFwB,SAAd,CAAlB;AAIA/B,QAAAA,IAAI,CAACkB,wBAAL,CAA8BW,SAA9B,EAAyCJ,GAAzC;AACD,OAXM,EAAP;;AAaF,SAAK,mBAAL;AACE;AACAM,MAAAA,OAAO,GAAGR,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACAL,MAAAA,OAAO,GAAGT,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACAP,MAAAA,WAAW,GAAGP,OAAO,CAACc,MAAR,CAAe,CAAf,KAAqB,EAAnC;AACAR,MAAAA,SAAS,GAAGtC,MAAM,CAACuC,WAAD,EAAc;AAC9BU,QAAAA,IAAI,EAAER,OADwB;AAE9BS,QAAAA,IAAI,EAAEV;AAFwB,OAAd,CAAlB;AAIA9C,MAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACqD,oBAAL,CAA0BxB,SAA1B,EAAqCS,EAArC,CADA,EAEPA,EAAD,IAAQtC,IAAI,CAACO,mBAAL,CAAyBsB,SAAzB,EAAoCS,EAApC,CAFA,CAAD,EAGNb,GAHM,CAAT;AAIA;;AAEF,SAAK,wBAAL;AACEG,MAAAA,QAAQ,GAAGL,OAAO,CAACc,MAAR,CAAe,CAAf,CAAX;AACArC,MAAAA,IAAI,CAACsD,qBAAL,CAA2B1B,QAA3B,EAAqCH,GAArC;AACA;;AAEF,SAAK,iBAAL;AACEO,MAAAA,OAAO,GAAGT,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACAN,MAAAA,OAAO,GAAGR,OAAO,CAACc,MAAR,CAAe,CAAf,CAAV;AACArC,MAAAA,IAAI,CAACuD,cAAL,CAAoBvB,OAApB,EAA6BD,OAA7B,EAAsCN,GAAtC;AACA;;AAEF,SAAK,qBAAL;AACE,aAAQ,YAAU;AAChB,cAAM+B,SAAS,GAAGjC,OAAO,CAACc,MAAR,CAAe,CAAf,CAAlB;AACArC,QAAAA,IAAI,CAACyD,kBAAL,CAAwBD,SAAxB,EAAmC/B,GAAnC;AACD,OAHM,EAAP;;AAKF,SAAK,uBAAL;AACEzB,MAAAA,IAAI,CAACE,WAAL,CAAiB,UAASgC,GAAT,EAAcC,QAAd,EAAuB;AACtC,YAAID,GAAJ,EAAS,OAAOT,GAAG,CAACS,GAAD,CAAV;AACT,cAAMwB,OAAO,GAAGvB,QAAQ,CAAC,CAAD,CAAR,IAAe,IAA/B;AACAV,QAAAA,GAAG,CAAC,IAAD,EAAOiC,OAAP,CAAH;AACD,OAJD;AAKA;;AAEF;AACElC,MAAAA,IAAI;AACJ;AApJJ;AAuJD,CAjKD,C,CAmKA;AACA;AACA;;;AAEA1B,uBAAuB,CAACuB,SAAxB,CAAkCnB,WAAlC,GAAgD,UAASoC,EAAT,EAAa;AAC3DA,EAAAA,EAAE,CAAC,IAAD,EAAO,EAAP,CAAF;AACD,CAFD,C,CAKA;AACA;AACA;;;AAEAxC,uBAAuB,CAACuB,SAAxB,CAAkClB,kBAAlC,GAAuD,UAASyB,QAAT,EAAmBU,EAAnB,EAAuB;AAC5E,QAAMtC,IAAI,GAAG,IAAb;AACAf,EAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACQ,kBAAL,CAAwBoB,QAAxB,EAAkCU,EAAlC,CADA,EAER,CAACqB,UAAD,EAAarB,EAAb,KAAoBtC,IAAI,CAAC4D,aAAL,CAAmB,aAAnB,EAAkCD,UAAlC,EAA8CrB,EAA9C,CAFZ,EAGPA,EAAD,IAAQtC,IAAI,CAAC6D,mBAAL,CAAyBjC,QAAzB,EAAmCU,EAAnC,CAHA,CAAD,EAINA,EAJM,CAAT;AAKD,CAPD;;AAUAxC,uBAAuB,CAACuB,SAAxB,CAAkCjB,sBAAlC,GAA2D,UAASwB,QAAT,EAAmBU,EAAnB,EAAuB;AAChF,QAAMtC,IAAI,GAAG,IAAb;AACAf,EAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACQ,kBAAL,CAAwBoB,QAAxB,EAAkCU,EAAlC,CADA,EAER,CAACqB,UAAD,EAAarB,EAAb,KAAoBtC,IAAI,CAAC4D,aAAL,CAAmB,aAAnB,EAAkCD,UAAlC,EAA8CrB,EAA9C,CAFZ,EAGPA,EAAD,IAAQtC,IAAI,CAAC8D,UAAL,CAAgBlC,QAAhB,EAA0BU,EAA1B,CAHA,CAAD,EAINA,EAJM,CAAT;AAKD,CAPD;;AASAxC,uBAAuB,CAACuB,SAAxB,CAAkChB,cAAlC,GAAmD,UAASwB,SAAT,EAAoBS,EAApB,EAAwB;AACzE,QAAMtC,IAAI,GAAG,IAAb;AACAf,EAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACU,cAAL,CAAoBmB,SAApB,EAA+BS,EAA/B,CADA,EAER,CAACqB,UAAD,EAAarB,EAAb,KAAoBtC,IAAI,CAAC4D,aAAL,CAAmB,SAAnB,EAA8BD,UAA9B,EAA0CrB,EAA1C,CAFZ,EAGPA,EAAD,IAAQtC,IAAI,CAACe,WAAL,CAAiBc,SAAjB,EAA4BS,EAA5B,CAHA,CAAD,EAINA,EAJM,CAAT;AAKD,CAPD;;AASAxC,uBAAuB,CAACuB,SAAxB,CAAkCf,sBAAlC,GAA2D,UAASuB,SAAT,EAAoBS,EAApB,EAAwB;AACjF,QAAMtC,IAAI,GAAG,IAAb;AACAf,EAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACW,sBAAL,CAA4BkB,SAA5B,EAAuCS,EAAvC,CADA,EAER,CAACqB,UAAD,EAAarB,EAAb,KAAoBtC,IAAI,CAAC4D,aAAL,CAAmB,SAAnB,EAA8BD,UAA9B,EAA0CrB,EAA1C,CAFZ,EAGPA,EAAD,IAAQtC,IAAI,CAACgB,mBAAL,CAAyBa,SAAzB,EAAoCS,EAApC,CAHA,CAAD,EAINA,EAJM,CAAT;AAKD,CAPD;;AASAxC,uBAAuB,CAACuB,SAAxB,CAAkCd,mBAAlC,GAAwD,UAASsB,SAAT,EAAoBS,EAApB,EAAwB;AAC9E,QAAMtC,IAAI,GAAG,IAAb;AACAf,EAAAA,SAAS,CAAC,CACPqD,EAAD,IAAQtC,IAAI,CAACY,mBAAL,CAAyBiB,SAAzB,EAAoCS,EAApC,CADA,EAER,CAACqB,UAAD,EAAarB,EAAb,KAAoBtC,IAAI,CAAC4D,aAAL,CAAmB,SAAnB,EAA8BD,UAA9B,EAA0CrB,EAA1C,CAFZ,EAGPA,EAAD,IAAQtC,IAAI,CAACiB,gBAAL,CAAsBY,SAAtB,EAAiCS,EAAjC,CAHA,CAAD,EAINA,EAJM,CAAT;AAKD,CAPD,C,CASA;AACA;AACA;;;AAEAxC,uBAAuB,CAACuB,SAAxB,CAAkCZ,WAAlC,GAAgD,UAASmB,QAAT,EAAmBU,EAAnB,EAAuB;AACrEA,EAAAA,EAAE,CAAC,IAAD,EAAO,IAAP,CAAF;AACD,CAFD;;AAIAxC,uBAAuB,CAACuB,SAAxB,CAAkCuC,aAAlC,GAAkD,UAASG,IAAT,EAAeJ,UAAf,EAA2BrB,EAA3B,EAA+B;AAC/EA,EAAAA,EAAE,CAAEqB,UAAU,GAAG,IAAH,GAAU,IAAIK,KAAJ,CAAU,iBAAeD,IAAf,GAAoB,aAA9B,CAAtB,CAAF;AACD,CAFD,C,CAIA;AACA;AACA;;;AAEAjE,uBAAuB,CAACuB,SAAxB,CAAkCiC,qBAAlC,GAA0D,UAAS1B,QAAT,EAAmBU,EAAnB,EAAuB;AAC/E,QAAMtC,IAAI,GAAG,IAAb,CAD+E,CAG/E;;AACA,QAAMiE,KAAK,GAAGjE,IAAI,CAAC2B,mBAAnB;AACA,QAAMuC,KAAK,GAAI,KAAID,KAAK,CAACE,QAAN,CAAe,EAAf,CAAmB,EAAtC;AACAnE,EAAAA,IAAI,CAAC2B,mBAAL;AAEA3B,EAAAA,IAAI,CAACoE,WAAL,CAAiB;AACfnC,IAAAA,MAAM,EAAE,qBADO;AAEfI,IAAAA,MAAM,EAAE,CAACT,QAAD;AAFO,GAAjB,EAGG,UAASyC,KAAT,EAAgBC,GAAhB,EAAoB;AACrB,QAAID,KAAJ,EAAW;AACTrE,MAAAA,IAAI,CAAC0B,eAAL,CAAqBwC,KAArB,IAA8B;AAAEG,QAAAA;AAAF,OAA9B;AACA;AACD;;AACD,UAAME,MAAM,GAAGD,GAAG,CAAClC,MAAnB;AACApC,IAAAA,IAAI,CAAC0B,eAAL,CAAqBwC,KAArB,IAA8BK,MAA9B;AACD,GAVD;AAYAjC,EAAAA,EAAE,CAAC,IAAD,EAAO4B,KAAP,CAAF;AACD,CArBD;;AAwBApE,uBAAuB,CAACuB,SAAxB,CAAkCkC,cAAlC,GAAmD,UAASvB,OAAT,EAAkBD,OAAlB,EAA2BO,EAA3B,EAA+B;AAChF,QAAMtC,IAAI,GAAG,IAAb,CADgF,CAGhF;;AACA,QAAMiE,KAAK,GAAGjE,IAAI,CAAC2B,mBAAnB;AACA,QAAMuC,KAAK,GAAI,KAAID,KAAK,CAACE,QAAN,CAAe,EAAf,CAAmB,EAAtC;AACAnE,EAAAA,IAAI,CAAC2B,mBAAL;AAEA3B,EAAAA,IAAI,CAACoE,WAAL,CAAiB;AACfnC,IAAAA,MAAM,EAAE,UADO;AAEfI,IAAAA,MAAM,EAAE,CAACL,OAAD,EAAUD,OAAV;AAFO,GAAjB,EAGG,UAASsC,KAAT,EAAgBC,GAAhB,EAAoB;AACrB,QAAID,KAAJ,EAAW;AACTrE,MAAAA,IAAI,CAAC0B,eAAL,CAAqBwC,KAArB,IAA8B;AAAEG,QAAAA;AAAF,OAA9B;AACA;AACD;;AACD,UAAMjC,MAAM,GAAGkC,GAAG,CAAClC,MAAnB;AACApC,IAAAA,IAAI,CAAC0B,eAAL,CAAqBwC,KAArB,IAA8B9B,MAA9B;AACD,GAVD;AAYAE,EAAAA,EAAE,CAAC,IAAD,EAAO4B,KAAP,CAAF;AACD,CArBD;;AAuBApE,uBAAuB,CAACuB,SAAxB,CAAkCoC,kBAAlC,GAAuD,UAASS,KAAT,EAAgB5B,EAAhB,EAAoB;AACzE,QAAMtC,IAAI,GAAG,IAAb;AACA,QAAMoC,MAAM,GAAGpC,IAAI,CAAC0B,eAAL,CAAqBwC,KAArB,KAA+B,IAA9C,CAFyE,CAGzE;;AACA,MAAI,CAAC9B,MAAL,EAAa,OAAOE,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT,CAJ4D,CAKzE;;AACA,MAAIF,MAAM,CAACiC,KAAX,EAAkB,OAAO/B,EAAE,CAACF,MAAM,CAACiC,KAAR,CAAT,CANuD,CAOzE;;AACA/B,EAAAA,EAAE,CAAC,IAAD,EAAOF,MAAP,CAAF;AACD,CATD,C,CAWA;AACA;AACA;;;AAEAtC,uBAAuB,CAACuB,SAAxB,CAAkCH,wBAAlC,GAA6D,UAASW,SAAT,EAAoBS,EAApB,EAAwB;AACnF,MAAIkC,SAAJ;;AACA,MAAI;AACFA,IAAAA,SAAS,GAAGlF,OAAO,CAAC4B,wBAAR,CAAiCW,SAAjC,CAAZ;AACD,GAFD,CAEE,OAAOK,GAAP,EAAY;AACZ,WAAOI,EAAE,CAACJ,GAAD,CAAT;AACD;;AACDI,EAAAA,EAAE,CAAC,IAAD,EAAOkC,SAAP,CAAF;AACD,CARD,C,CAUA;AACA;AACA;;;AAEA1E,uBAAuB,CAACuB,SAAxB,CAAkCkB,mBAAlC,GAAwD,UAASX,QAAT,EAAmBU,EAAnB,EAAsB;AAC5E,QAAMtC,IAAI,GAAG,IAAb,CAD4E,CAE5E;;AACA,MAAI4B,QAAQ,CAACY,IAAT,KAAkBiC,SAAtB,EAAiC,OAAOnC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,gEAAX,CAAD,CAAT;AACjChE,EAAAA,IAAI,CAAC0E,cAAL,CAAoB9C,QAAQ,CAACY,IAA7B,EAAmC,UAASN,GAAT,EAAcyC,aAAd,EAA4B;AAC7D,QAAIzC,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACT,QAAI,CAACyC,aAAL,EAAoB,OAAOrC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,mEAAkEpC,QAAQ,CAACY,IAAK,GAA3F,CAAD,CAAT;AACpBF,IAAAA,EAAE;AACH,GAJD;AAKD,CATD;;AAWAxC,uBAAuB,CAACuB,SAAxB,CAAkCqB,eAAlC,GAAoD,UAASb,SAAT,EAAoBS,EAApB,EAAuB;AACzE,QAAMtC,IAAI,GAAG,IAAb;AACA,MAAI6B,SAAS,CAACW,IAAV,KAAmBiC,SAAvB,EAAkC,OAAOnC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,4DAAX,CAAD,CAAT;AAClChE,EAAAA,IAAI,CAAC0E,cAAL,CAAoB7C,SAAS,CAACW,IAA9B,EAAoC,UAASN,GAAT,EAAcyC,aAAd,EAA4B;AAC9D,QAAIzC,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACT,QAAI,CAACyC,aAAL,EAAoB,OAAOrC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,+DAA8DnC,SAAS,CAACW,IAAK,GAAxF,CAAD,CAAT;AACpBF,IAAAA,EAAE;AACH,GAJD;AAKD,CARD;;AAUAxC,uBAAuB,CAACuB,SAAxB,CAAkC6B,uBAAlC,GAA4D,UAASrB,SAAT,EAAoBS,EAApB,EAAuB;AACjF,QAAMtC,IAAI,GAAG,IAAb;AACA,MAAI6B,SAAS,CAACW,IAAV,KAAmBiC,SAAvB,EAAkC,OAAOnC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,qEAAX,CAAD,CAAT;AAClC,MAAInC,SAAS,CAACY,IAAV,KAAmBgC,SAAvB,EAAkC,OAAOnC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,gEAAX,CAAD,CAAT;AAClC,MAAI,CAACY,UAAU,CAAC/C,SAAS,CAACY,IAAX,CAAf,EAAiC,OAAOH,EAAE,CAAC,IAAI0B,KAAJ,CAAW,6EAAX,CAAD,CAAT;AACjChE,EAAAA,IAAI,CAAC0E,cAAL,CAAoB7C,SAAS,CAACW,IAA9B,EAAoC,UAASN,GAAT,EAAcyC,aAAd,EAA4B;AAC9D,QAAIzC,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACT,QAAI,CAACyC,aAAL,EAAoB,OAAOrC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,+DAA8DnC,SAAS,CAACW,IAAK,GAAxF,CAAD,CAAT;AACpBF,IAAAA,EAAE;AACH,GAJD;AAKD,CAVD;;AAYAxC,uBAAuB,CAACuB,SAAxB,CAAkCgC,oBAAlC,GAAyD,UAASxB,SAAT,EAAoBS,EAApB,EAAuB;AAC9E,MAAIT,SAAS,CAACW,IAAV,KAAmBiC,SAAvB,EAAkC,OAAOnC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,+DAAX,CAAD,CAAT;AAClC,MAAInC,SAAS,CAACY,IAAV,KAAmBgC,SAAvB,EAAkC,OAAOnC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,uDAAX,CAAD,CAAT;AAClC,OAAKU,cAAL,CAAoB7C,SAAS,CAACW,IAA9B,EAAoC,UAASN,GAAT,EAAcyC,aAAd,EAA4B;AAC9D,QAAIzC,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACT,QAAI,CAACyC,aAAL,EAAoB,OAAOrC,EAAE,CAAC,IAAI0B,KAAJ,CAAW,+DAA8DnC,SAAS,CAACW,IAAK,GAAxF,CAAD,CAAT;AACpBF,IAAAA,EAAE;AACH,GAJD;AAKD,CARD;;AAUAxC,uBAAuB,CAACuB,SAAxB,CAAkCqD,cAAlC,GAAmD,UAASG,aAAT,EAAwBvC,EAAxB,EAA2B;AAC5E,QAAMtC,IAAI,GAAG,IAAb,CAD4E,CAE5E;;AACA,MAAI,CAAC6E,aAAL,EAAoB,OAAOvC,EAAE,CAAC,IAAD,EAAO,KAAP,CAAT;AACpBtC,EAAAA,IAAI,CAACE,WAAL,CAAiB,UAASgC,GAAT,EAAcC,QAAd,EAAuB;AACtC,QAAID,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACT,UAAMyC,aAAa,GAAIxC,QAAQ,CAAC2C,GAAT,CAAaC,WAAb,EAA0BC,OAA1B,CAAkCH,aAAa,CAACE,WAAd,EAAlC,MAAmE,CAAC,CAA3F;AACAzC,IAAAA,EAAE,CAAC,IAAD,EAAOqC,aAAP,CAAF;AACD,GAJD;AAKD,CATD,C,CAWA;AACA;AACA;;;AAEA7E,uBAAuB,CAACuB,SAAxB,CAAkCwC,mBAAlC,GAAwD,UAASjC,QAAT,EAAmBU,EAAnB,EAAuB;AAC7E,QAAMtC,IAAI,GAAG,IAAb,CAD6E,CAE7E;AACA;;AACAA,EAAAA,IAAI,CAACC,SAAL,CAAegF,IAAf,CAAoB,YAAU;AAC5BhG,IAAAA,SAAS,CAAC,CACRe,IAAI,CAACkF,cAAL,CAAoBC,IAApB,CAAyBnF,IAAzB,EAA+B4B,QAA/B,CADQ,EAER5B,IAAI,CAACa,eAAL,CAAqBsE,IAArB,CAA0BnF,IAA1B,CAFQ,EAGRA,IAAI,CAACmB,kBAAL,CAAwBgE,IAAxB,CAA6BnF,IAA7B,CAHQ,CAAD,EAIN,UAASkC,GAAT,EAAcqC,MAAd,EAAqB;AACtBvE,MAAAA,IAAI,CAACC,SAAL,CAAemF,KAAf;AACA,UAAIlD,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACTI,MAAAA,EAAE,CAAC,IAAD,EAAOiC,MAAP,CAAF;AACD,KARQ,CAAT;AASD,GAVD;AAWD,CAfD;;AAiBAzE,uBAAuB,CAACuB,SAAxB,CAAkCyC,UAAlC,GAA+C,UAASlC,QAAT,EAAmBU,EAAnB,EAAuB;AACpE,QAAMtC,IAAI,GAAG,IAAb,CADoE,CAEpE;AACA;;AACAA,EAAAA,IAAI,CAACC,SAAL,CAAegF,IAAf,CAAoB,YAAU;AAC5BhG,IAAAA,SAAS,CAAC,CACRe,IAAI,CAACkF,cAAL,CAAoBC,IAApB,CAAyBnF,IAAzB,EAA+B4B,QAA/B,CADQ,EAER5B,IAAI,CAACa,eAAL,CAAqBsE,IAArB,CAA0BnF,IAA1B,CAFQ,CAAD,EAGN,UAASkC,GAAT,EAAcmD,QAAd,EAAuB;AACxBrF,MAAAA,IAAI,CAACC,SAAL,CAAemF,KAAf;AACA,UAAIlD,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACTI,MAAAA,EAAE,CAAC,IAAD,EAAO;AAACgD,QAAAA,GAAG,EAAED,QAAN;AAAgBE,QAAAA,EAAE,EAAE3D;AAApB,OAAP,CAAF;AACD,KAPQ,CAAT;AAQD,GATD;AAUD,CAdD;;AAgBA9B,uBAAuB,CAACuB,SAAxB,CAAkCF,kBAAlC,GAAuD,UAASqE,KAAT,EAAgBlD,EAAhB,EAAoB;AACzE,QAAMtC,IAAI,GAAG,IAAb;AACAA,EAAAA,IAAI,CAACoE,WAAL,CAAiB;AACfnC,IAAAA,MAAM,EAAE,wBADO;AAEfI,IAAAA,MAAM,EAAE,CAACmD,KAAD;AAFO,GAAjB,EAGG,UAAStD,GAAT,EAAcoC,GAAd,EAAkB;AACnB,QAAIpC,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACTI,IAAAA,EAAE,CAAC,IAAD,EAAOgC,GAAG,CAAClC,MAAX,CAAF;AACD,GAND;AAOD,CATD;;AAWAtC,uBAAuB,CAACuB,SAAxB,CAAkC3B,WAAlC,GAAgD,UAASkC,QAAT,EAAmBU,EAAnB,EAAuB;AACrE,QAAMtC,IAAI,GAAG,IAAb;AACAN,EAAAA,WAAW,CAACM,IAAI,CAACyF,MAAN,EAAc7D,QAAd,EAAwBU,EAAxB,CAAX;AACD,CAHD;;AAKAxC,uBAAuB,CAACuB,SAAxB,CAAkCD,WAAlC,GAAgD,UAASkB,EAAT,EAAa;AAC3D,QAAMtC,IAAI,GAAG,IAAb;AACAA,EAAAA,IAAI,CAACoE,WAAL,CAAiB;AAAEnC,IAAAA,MAAM,EAAE,cAAV;AAA0BI,IAAAA,MAAM,EAAE;AAAlC,GAAjB,EAAyD,UAAUH,GAAV,EAAeoC,GAAf,EAAoB;AAC3E,QAAIpC,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AACTI,IAAAA,EAAE,CAAC,IAAD,EAAOgC,GAAG,CAAClC,MAAX,CAAF;AACD,GAHD;AAID,CAND;;AAQAtC,uBAAuB,CAACuB,SAAxB,CAAkC6D,cAAlC,GAAmD,UAAStD,QAAT,EAAmBU,EAAnB,EAAsB;AACvE,QAAMtC,IAAI,GAAG,IAAb;AACA,QAAMgC,OAAO,GAAGJ,QAAQ,CAACY,IAAzB,CAFuE,CAGvE;;AAEA,QAAMkD,KAAK,GAAG,EAAd;;AAEA,MAAI9D,QAAQ,CAAC+D,QAAT,KAAsBlB,SAA1B,EAAqC;AACnC;AACAiB,IAAAA,KAAK,CAACC,QAAN,GAAiB3F,IAAI,CAACoB,WAAL,CAAiB+D,IAAjB,CAAsBnF,IAAtB,CAAjB;AACD;;AAED,MAAI4B,QAAQ,CAACgE,KAAT,KAAmBnB,SAAvB,EAAkC;AAChC;AACAiB,IAAAA,KAAK,CAACE,KAAN,GAAc5F,IAAI,CAACoE,WAAL,CAAiBe,IAAjB,CAAsBnF,IAAtB,EAA4B;AAAEiC,MAAAA,MAAM,EAAE,yBAAV;AAAqCI,MAAAA,MAAM,EAAE,CAACL,OAAD,EAAU,SAAV;AAA7C,KAA5B,CAAd;AACD;;AAED,MAAIJ,QAAQ,CAACiE,GAAT,KAAiBpB,SAArB,EAAgC;AAC9B;AACAiB,IAAAA,KAAK,CAACG,GAAN,GAAY7F,IAAI,CAACN,WAAL,CAAiByF,IAAjB,CAAsBnF,IAAtB,EAA4B8F,aAAa,CAAClE,QAAD,CAAzC,CAAZ;AACD;;AAEDzC,EAAAA,QAAQ,CAACuG,KAAD,EAAQ,UAASxD,GAAT,EAAc6D,WAAd,EAA2B;AACzC,QAAI7D,GAAJ,EAAS,OAAOI,EAAE,CAACJ,GAAD,CAAT;AAET,UAAME,MAAM,GAAG,EAAf;AACA,QAAI2D,WAAW,CAACJ,QAAhB,EAA0BvD,MAAM,CAACuD,QAAP,GAAkBI,WAAW,CAACJ,QAA9B;AAC1B,QAAII,WAAW,CAACH,KAAhB,EAAuBxD,MAAM,CAACwD,KAAP,GAAeG,WAAW,CAACH,KAAZ,CAAkBxD,MAAjC;AACvB,QAAI2D,WAAW,CAACF,GAAhB,EAAqBzD,MAAM,CAACyD,GAAP,GAAaE,WAAW,CAACF,GAAzB;AAErBvD,IAAAA,EAAE,CAAC,IAAD,EAAO/C,MAAM,CAACqC,QAAD,EAAWQ,MAAX,CAAb,CAAF;AACD,GATO,CAAR;AAUD,CAhCD,C,CAkCA;AAEA;;;AACA,SAAS0D,aAAT,CAAuBlE,QAAvB,EAAgC;AAC9B,SAAO;AACLY,IAAAA,IAAI,EAAEZ,QAAQ,CAACY,IADV;AAELwD,IAAAA,EAAE,EAAEpE,QAAQ,CAACoE,EAFR;AAGLC,IAAAA,KAAK,EAAErE,QAAQ,CAACqE,KAHX;AAILxD,IAAAA,IAAI,EAAEb,QAAQ,CAACa,IAJV;AAKLoD,IAAAA,GAAG,EAAEjE,QAAQ,CAACiE,GALT;AAMLF,IAAAA,QAAQ,EAAE/D,QAAQ,CAAC+D,QANd;AAOLC,IAAAA,KAAK,EAAEhE,QAAQ,CAACgE;AAPX,GAAP;AASD;;AAED,SAASb,WAAT,CAAqBmB,MAArB,EAA4B;AAC1B,SAAOA,MAAM,CAACnB,WAAP,EAAP;AACD;;AAED,SAASjC,gBAAT,CAA2BoD,MAA3B,EAAmC;AACjC,QAAMC,KAAK,GAAG9G,OAAO,CAAC+G,YAAR,CAAqBF,MAArB,CAAd;AACA,QAAMG,OAAO,GAAGhH,OAAO,CAACiH,cAAR,CAAuBH,KAAvB,CAAhB;AACA,SAAOE,OAAP;AACD,C,CAED;AACA;;;AACA,SAASxD,aAAT,CAAwBqD,MAAxB,EAAgC;AAC9B,QAAMC,KAAK,GAAG9G,OAAO,CAAC+G,YAAR,CAAqBF,MAArB,CAAd;AACA,QAAMI,cAAc,GAAGjH,OAAO,CAACiH,cAAR,CAAuBH,KAAvB,CAAvB;AACA,SAAO,CAACG,cAAD,IAAmB1B,UAAU,CAACsB,MAAD,CAApC;AACD;;AAED,SAAStB,UAAT,CAAoBnC,IAApB,EAA0B;AACxB,QAAM8D,QAAQ,GAAG,OAAO9D,IAAP,KAAgB,QAAjC;AACA,MAAI,CAAC8D,QAAL,EAAe,OAAO,KAAP;AACf,QAAMC,aAAa,GAAG/D,IAAI,CAACgE,KAAL,CAAW,CAAX,EAAa,CAAb,MAAoB,IAA1C;AACA,MAAI,CAACD,aAAL,EAAoB,OAAO,KAAP;AACpB,QAAME,WAAW,GAAGjE,IAAI,CAACgE,KAAL,CAAW,CAAX,CAApB;AACA,QAAMJ,OAAO,GAAGK,WAAW,CAACC,KAAZ,CAAkBhH,QAAlB,CAAhB;AACA,SAAO0G,OAAP;AACD;;AAED,SAASvF,wBAAT,CAAkC8F,UAAlC,EAA8C;AAC5C,SAAO,UAASvE,MAAT,EAAiBC,EAAjB,EAAqB;AAC1BA,IAAAA,EAAE,CAAC,IAAI0B,KAAJ,CAAU,8DAA8D4C,UAA9D,GAA2E,6BAArF,CAAD,CAAF;AACD,GAFD;AAGD","sourcesContent":["/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\n\nconst waterfall = require('async/waterfall')\nconst parallel = require('async/parallel')\nconst inherits = require('util').inherits\nconst ethUtil = require('ethereumjs-util')\nconst sigUtil = require('eth-sig-util')\nconst extend = require('xtend')\nconst Semaphore = require('semaphore')\nconst Subprovider = require('./subprovider.js')\nconst estimateGas = require('../util/estimate-gas.js')\nconst hexRegex = /^[0-9A-Fa-f]+$/g\n\nmodule.exports = HookedWalletSubprovider\n\n// handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   personal_sign\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\n\ninherits(HookedWalletSubprovider, Subprovider)\n\nfunction HookedWalletSubprovider(opts){\n  const self = this\n  // control flow\n  self.nonceLock = Semaphore(1)\n\n  // data lookup\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts\n  // high level override\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction\n  if (opts.processSignTransaction) self.processSignTransaction = opts.processSignTransaction\n  if (opts.processMessage) self.processMessage = opts.processMessage\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage\n  // approval hooks\n  self.approveTransaction = opts.approveTransaction || self.autoApprove\n  self.approveMessage = opts.approveMessage || self.autoApprove\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove\n  // actually perform the signature\n  self.signTransaction = opts.signTransaction  || mustProvideInConstructor('signTransaction')\n  self.signMessage = opts.signMessage  || mustProvideInConstructor('signMessage')\n  self.signPersonalMessage = opts.signPersonalMessage  || mustProvideInConstructor('signPersonalMessage')\n  self.signTypedMessage = opts.signTypedMessage  || mustProvideInConstructor('signTypedMessage')\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature\n  // publish to network\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction\n  // gas options\n  self.estimateGas = opts.estimateGas || self.estimateGas\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n  self._parityRequests = {}\n  self._parityRequestCount = 0\n\n  // switch statement is not block scoped\n  // sp we cant repeat var declarations\n  let txParams, msgParams, extraParams\n  let message, address\n\n  switch(payload.method) {\n\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        let result = accounts[0] || null\n        end(null, result)\n      })\n      return\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        end(null, accounts)\n      })\n      return\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processSignTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0]\n      message = payload.params[1]\n      // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n      extraParams = payload.params[2] || {}\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message,\n      })\n      waterfall([\n        (cb) => self.validateMessage(msgParams, cb),\n        (cb) => self.processMessage(msgParams, cb),\n      ], end)\n      return\n\n    case 'personal_sign':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validatePersonalMessage(msgParams, cb),\n          (cb) => self.processPersonalMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'personal_ecRecover':\n      return (function(){    \n        message = payload.params[0]\n        let signature = payload.params[1]\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message,\n        })\n        self.recoverPersonalSignature(msgParams, end)\n      })()\n\n    case 'eth_signTypedData':\n      // process normally\n      message = payload.params[0]\n      address = payload.params[1]\n      extraParams = payload.params[2] || {}\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message,\n      })\n      waterfall([\n        (cb) => self.validateTypedMessage(msgParams, cb),\n        (cb) => self.processTypedMessage(msgParams, cb),\n      ], end)\n      return\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0]\n      self.parityPostTransaction(txParams, end)\n      return\n\n    case 'parity_postSign':\n      address = payload.params[0]\n      message = payload.params[1]\n      self.parityPostSign(address, message, end)\n      return\n\n    case 'parity_checkRequest':\n      return (function(){\n        const requestId = payload.params[0]\n        self.parityCheckRequest(requestId, end)\n      })()\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        const account = accounts[0] || null\n        end(null, account)\n      })\n      return\n\n    default:\n      next()\n      return\n\n  }\n}\n\n//\n// data lookup\n//\n\nHookedWalletSubprovider.prototype.getAccounts = function(cb) {\n  cb(null, [])\n}\n\n\n//\n// \"process\" high level flow\n//\n\nHookedWalletSubprovider.prototype.processTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeAndSubmitTx(txParams, cb),\n  ], cb)\n}\n\n\nHookedWalletSubprovider.prototype.processSignTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeTx(txParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approvePersonalMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signPersonalMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processTypedMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTypedMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signTypedMessage(msgParams, cb),\n  ], cb)\n}\n\n//\n// approval\n//\n\nHookedWalletSubprovider.prototype.autoApprove = function(txParams, cb) {\n  cb(null, true)\n}\n\nHookedWalletSubprovider.prototype.checkApproval = function(type, didApprove, cb) {\n  cb( didApprove ? null : new Error('User denied '+type+' signature.') )\n}\n\n//\n// parity\n//\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function(txParams, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const txHash = res.result\n    self._parityRequests[reqId] = txHash\n  })\n\n  cb(null, reqId)\n}\n\n\nHookedWalletSubprovider.prototype.parityPostSign = function(address, message, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const result = res.result\n    self._parityRequests[reqId] = result\n  })\n\n  cb(null, reqId)\n}\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function(reqId, cb) {\n  const self = this\n  const result = self._parityRequests[reqId] || null\n  // tx not handled yet\n  if (!result) return cb(null, null)\n  // tx was rejected (or other error)\n  if (result.error) return cb(result.error)\n  // tx sent\n  cb(null, result)\n}\n\n//\n// signature and recovery\n//\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function(msgParams, cb) {\n  let senderHex\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams)\n  } catch (err) {\n    return cb(err)\n  }\n  cb(null, senderHex)\n}\n\n//\n// validation\n//\n\nHookedWalletSubprovider.prototype.validateTransaction = function(txParams, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`))\n  self.validateSender(txParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function(msgParams, cb){\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`))\n  this.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateSender = function(senderAddress, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (!senderAddress) return cb(null, false)\n  self.getAccounts(function(err, accounts){\n    if (err) return cb(err)\n    const senderIsValid = (accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1)\n    cb(null, senderIsValid)\n  })\n}\n\n//\n// tx helpers\n//\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n      self.publishTransaction.bind(self),\n    ], function(err, txHash){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, txHash)\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.finalizeTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n    ], function(err, signedTx){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, {raw: signedTx, tx: txParams})\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.publishTransaction = function(rawTx, cb) {\n  const self = this\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx],\n  }, function(err, res){\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.estimateGas = function(txParams, cb) {\n  const self = this\n  estimateGas(self.engine, txParams, cb)\n}\n\nHookedWalletSubprovider.prototype.getGasPrice = function(cb) {\n  const self = this\n  self.emitPayload({ method: 'eth_gasPrice', params: [] }, function (err, res) {\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function(txParams, cb){\n  const self = this\n  const address = txParams.from\n  // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {}\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self)\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, { method: 'eth_getTransactionCount', params: [address, 'pending'] })\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams))\n  }\n\n  parallel(tasks, function(err, taskResults) {\n    if (err) return cb(err)\n\n    const result = {}\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result\n    if (taskResults.gas) result.gas = taskResults.gas\n\n    cb(null, extend(txParams, result))\n  })\n}\n\n// util\n\n// we use this to clean any custom params from the txParams\nfunction cloneTxParams(txParams){\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce,\n  }\n}\n\nfunction toLowerCase(string){\n  return string.toLowerCase()\n}\n\nfunction resemblesAddress (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValid = ethUtil.isValidAddress(fixed)\n  return isValid\n}\n\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValidAddress = ethUtil.isValidAddress(fixed)\n  return !isValidAddress && isValidHex(string)\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string'\n  if (!isString) return false\n  const isHexPrefixed = data.slice(0,2) === '0x'\n  if (!isHexPrefixed) return false\n  const nonPrefixed = data.slice(2)\n  const isValid = nonPrefixed.match(hexRegex)\n  return isValid\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function(params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}