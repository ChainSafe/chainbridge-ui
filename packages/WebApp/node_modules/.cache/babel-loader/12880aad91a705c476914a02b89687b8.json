{"ast":null,"code":"import { __values } from \"tslib\";\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { Memo } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n/**\n * Wrap a given object method with a higher-order function\n *\n * @param source An object that contains a method to be wrapped.\n * @param name A name of method to be wrapped.\n * @param replacement A function that should be used to wrap a given method.\n * @returns void\n */\n\nexport function fill(source, name, replacement) {\n  if (!(name in source)) {\n    return;\n  }\n\n  var original = source[name];\n  var wrapped = replacement(original); // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __sentry_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    } catch (_Oo) {// This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\n\nexport function urlEncode(object) {\n  return Object.keys(object).map(function (key) {\n    return encodeURIComponent(key) + \"=\" + encodeURIComponent(object[key]);\n  }).join('&');\n}\n/**\n * Transforms any object into an object literal with all it's attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order to be usable by the serializer\n */\n\nfunction getWalkSource(value) {\n  if (isError(value)) {\n    var error = value;\n    var err = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n\n    for (var i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n\n    return err;\n  }\n\n  if (isEvent(value)) {\n    var event_1 = value;\n    var source = {};\n    source.type = event_1.type; // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n\n    try {\n      source.target = isElement(event_1.target) ? htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n\n    try {\n      source.currentTarget = isElement(event_1.currentTarget) ? htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event_1.detail;\n    }\n\n    for (var i in event_1) {\n      if (Object.prototype.hasOwnProperty.call(event_1, i)) {\n        source[i] = event_1;\n      }\n    }\n\n    return source;\n  }\n\n  return value;\n}\n/** Calculates bytes size of input string */\n\n\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n/** Calculates bytes size of input object */\n\n\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n/** JSDoc */\n\n\nexport function normalizeToSize(object, // Default Node.js REPL depth\ndepth, // 100kB, as 200kB is max payload size, so half sounds reasonable\nmaxSize) {\n  if (depth === void 0) {\n    depth = 3;\n  }\n\n  if (maxSize === void 0) {\n    maxSize = 100 * 1024;\n  }\n\n  var serialized = normalize(object, depth);\n\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return serialized;\n}\n/** Transforms any input value into a string form, either primitive value or a type of the input */\n\nfunction serializeValue(value) {\n  var type = Object.prototype.toString.call(value); // Node.js REPL notation\n\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n\n  var normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\n\n\nfunction normalizeValue(value, key) {\n  if (key === 'domain' && value && typeof value === 'object' && value._events) {\n    return '[Domain]';\n  }\n\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n\n  if (typeof global !== 'undefined' && value === global) {\n    return '[Global]';\n  }\n\n  if (typeof window !== 'undefined' && value === window) {\n    return '[Window]';\n  }\n\n  if (typeof document !== 'undefined' && value === document) {\n    return '[Document]';\n  } // React's SyntheticEvent thingy\n\n\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n\n  if (value === void 0) {\n    return '[undefined]';\n  }\n\n  if (typeof value === 'function') {\n    return \"[Function: \" + getFunctionName(value) + \"]\";\n  }\n\n  return value;\n}\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\nexport function walk(key, value, depth, memo) {\n  if (depth === void 0) {\n    depth = +Infinity;\n  }\n\n  if (memo === void 0) {\n    memo = new Memo();\n  } // If we reach the maximum depth, serialize whatever has left\n\n\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n\n\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further\n\n\n  var normalized = normalizeValue(value, key);\n\n  if (isPrimitive(normalized)) {\n    return normalized;\n  } // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself\n\n\n  var source = getWalkSource(value); // Create an accumulator that will act as a parent for all future itterations of that branch\n\n  var acc = Array.isArray(value) ? [] : {}; // If we already walked that branch, bail out, as it's circular reference\n\n  if (memo.memoize(value)) {\n    return '[Circular ~]';\n  } // Walk all keys of the source\n\n\n  for (var innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    } // Recursively walk through all the child nodes\n\n\n    acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  } // Once walked through all the branches, remove the parent from memo storage\n\n\n  memo.unmemoize(value); // Return accumulated values\n\n  return acc;\n}\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexport function normalize(input, depth) {\n  try {\n    return JSON.parse(JSON.stringify(input, function (key, value) {\n      return walk(key, value, depth);\n    }));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexport function extractExceptionKeysForMessage(exception, maxLength) {\n  if (maxLength === void 0) {\n    maxLength = 40;\n  }\n\n  var keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n\n    if (serialized.length > maxLength) {\n      continue;\n    }\n\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\n\nexport function dropUndefinedKeys(val) {\n  var e_1, _a;\n\n  if (isPlainObject(val)) {\n    var obj = val;\n    var rv = {};\n\n    try {\n      for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n\n        if (typeof obj[key] !== 'undefined') {\n          rv[key] = dropUndefinedKeys(obj[key]);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return rv;\n  }\n\n  if (Array.isArray(val)) {\n    return val.map(dropUndefinedKeys);\n  }\n\n  return val;\n}","map":{"version":3,"sources":["../src/object.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ExtendedError, WrappedFunction } from '@sentry/types';\n\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { Memo } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n\n/**\n * Wrap a given object method with a higher-order function\n *\n * @param source An object that contains a method to be wrapped.\n * @param name A name of method to be wrapped.\n * @param replacement A function that should be used to wrap a given method.\n * @returns void\n */\nexport function fill(source: { [key: string]: any }, name: string, replacement: (...args: any[]) => any): void {\n  if (!(name in source)) {\n    return;\n  }\n\n  const original = source[name] as () => any;\n  const wrapped = replacement(original) as WrappedFunction;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __sentry_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object: { [key: string]: any }): string {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any object into an object literal with all it's attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order to be usable by the serializer\n */\nfunction getWalkSource(\n  value: any,\n): {\n  [key: string]: any;\n} {\n  if (isError(value)) {\n    const error = value as ExtendedError;\n    const err: {\n      [key: string]: any;\n      stack: string | undefined;\n      message: string;\n      name: string;\n    } = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack,\n    };\n\n    for (const i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n\n    return err;\n  }\n\n  if (isEvent(value)) {\n    /**\n     * Event-like interface that's usable in browser and node\n     */\n    interface SimpleEvent {\n      [key: string]: unknown;\n      type: string;\n      target?: unknown;\n      currentTarget?: unknown;\n    }\n\n    const event = value as SimpleEvent;\n\n    const source: {\n      [key: string]: any;\n    } = {};\n\n    source.type = event.type;\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      source.target = isElement(event.target)\n        ? htmlTreeAsString(event.target)\n        : Object.prototype.toString.call(event.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n\n    try {\n      source.currentTarget = isElement(event.currentTarget)\n        ? htmlTreeAsString(event.currentTarget)\n        : Object.prototype.toString.call(event.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event.detail;\n    }\n\n    for (const i in event) {\n      if (Object.prototype.hasOwnProperty.call(event, i)) {\n        source[i] = event;\n      }\n    }\n\n    return source;\n  }\n\n  return value as {\n    [key: string]: any;\n  };\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value: string): number {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value: any): number {\n  return utf8Length(JSON.stringify(value));\n}\n\n/** JSDoc */\nexport function normalizeToSize<T>(\n  object: { [key: string]: any },\n  // Default Node.js REPL depth\n  depth: number = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize: number = 100 * 1024,\n): T {\n  const serialized = normalize(object, depth);\n\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return serialized as T;\n}\n\n/** Transforms any input value into a string form, either primitive value or a type of the input */\nfunction serializeValue(value: any): any {\n  const type = Object.prototype.toString.call(value);\n\n  // Node.js REPL notation\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n\n  const normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\nfunction normalizeValue<T>(value: T, key?: any): T | string {\n  if (key === 'domain' && value && typeof value === 'object' && ((value as unknown) as { _events: any })._events) {\n    return '[Domain]';\n  }\n\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n\n  if (typeof (global as any) !== 'undefined' && (value as unknown) === global) {\n    return '[Global]';\n  }\n\n  if (typeof (window as any) !== 'undefined' && (value as unknown) === window) {\n    return '[Window]';\n  }\n\n  if (typeof (document as any) !== 'undefined' && (value as unknown) === document) {\n    return '[Document]';\n  }\n\n  // React's SyntheticEvent thingy\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n\n  if (value === void 0) {\n    return '[undefined]';\n  }\n\n  if (typeof value === 'function') {\n    return `[Function: ${getFunctionName(value)}]`;\n  }\n\n  return value;\n}\n\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function walk(key: string, value: any, depth: number = +Infinity, memo: Memo = new Memo()): any {\n  // If we reach the maximum depth, serialize whatever has left\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n  // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further\n  const normalized = normalizeValue(value, key);\n  if (isPrimitive(normalized)) {\n    return normalized;\n  }\n\n  // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself\n  const source = getWalkSource(value);\n\n  // Create an accumulator that will act as a parent for all future itterations of that branch\n  const acc = Array.isArray(value) ? [] : {};\n\n  // If we already walked that branch, bail out, as it's circular reference\n  if (memo.memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // Walk all keys of the source\n  for (const innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    }\n    // Recursively walk through all the child nodes\n    (acc as { [key: string]: any })[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  }\n\n  // Once walked through all the branches, remove the parent from memo storage\n  memo.unmemoize(value);\n\n  // Return accumulated values\n  return acc;\n}\n\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function normalize(input: any, depth?: number): any {\n  try {\n    return JSON.parse(JSON.stringify(input, (key: string, value: any) => walk(key, value, depth)));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception: any, maxLength: number = 40): string {\n  const keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys<T>(val: T): T {\n  if (isPlainObject(val)) {\n    const obj = val as { [key: string]: any };\n    const rv: { [key: string]: any } = {};\n    for (const key of Object.keys(obj)) {\n      if (typeof obj[key] !== 'undefined') {\n        rv[key] = dropUndefinedKeys(obj[key]);\n      }\n    }\n    return rv as T;\n  }\n\n  if (Array.isArray(val)) {\n    return val.map(dropUndefinedKeys) as any;\n  }\n\n  return val;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}